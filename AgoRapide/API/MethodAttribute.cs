using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;

namespace AgoRapide.API {

    /// <summary>
    /// General attributes for an API-method.
    /// 
    /// See slightly more refined class <see cref="MethodAttributeT"/>
    /// 
    /// TODO: Add some kind of SuggestedNextMethod / SuggestedNextCommand, that will be automatically added in HTML-responses
    /// TODO: to client. We have a problem of mapping them though, but autogenerated methods could contain such a thing. 
    /// </summary>
    public class MethodAttribute : Attribute {

        public CoreMethod CoreMethod { get; set; }
        public void AssertCoreMethod(CoreMethod coreMethod) {
            if (CoreMethod != coreMethod) throw new InvalidEnumException(CoreMethod, "Expected " + coreMethod);
        }

        /// <summary>
        /// TODO: TEXT BELOW IS NOT UPDATED. MAY BE IRRELEVANT NOW (JAN 2017)
        /// SEE INSTEAD Method-class for routing documentation.
        /// 
        /// If set to null, then routing will be based on name of the Controller and method like 
        /// PersonController.Index: api/Person/{id}
        /// PersonController.Add: api/Person/Add
        /// PersonController.AddProperty: api/Person/{id}/AddProperty/{key}/{value}
        /// EntityController.Index: api/Entity/{id}
        /// EntityController.Add: api/Entity/Add/{entity_type}
        /// EntityController.AddProperty: api/Entity/{id}/AddProperty/{key}/{value}
        /// PropertyController.SetNoLongerCurrent: api/Property/{id}/SetNoLongerCurrent
        /// 
        /// If the routing is given manually then auto discoverability will be implemented
        /// api/Person/{id}/AddProperty/{key}/{value}
        /// 
        /// In all cases discoverability will be implemented automatically, that is for
        /// api/Person/{id}/AddProperty/{key}/{value}
        /// the mechanism will also implement routings like
        /// api/Person/{id}/AddProperty/{key}
        /// api/Person/{id}/AddProperty
        /// api/Person//AddProperty
        /// 
        /// We need sample values for id's
        /// so for Person_id we need sample values like 42
        /// 
        /// UTFORDRING: Holde fra hverandre de ulike mulig verdiene.
        /// UTFORDRING: Tidsmessig og begrense scope på hele prosjektet.
        /// 
        /// I utgangspunktet så bør parameternavn i ruting tilsvare en property-verdi med tilhørende
        /// eksempel verdier.
        /// 
        /// if (!TryGetParameters(id, key, value, out parameters, out errorResponse)) return errorResponse
        /// Denne vil da finne parametere basert på klassenavn og metodenavn.
        /// 
        /// Hva med følgende:
        /// Route template api/Person/{?}/AddProperty/{?}/{?} og så bruker vi bare navn på parameterne slik
        /// som gitt i metode-deklarasjonen? Dermed kan vi endre navn på parameterne uten å måtte endre i rutingen.
        /// Eventuelt at vi krever at må matche 100%        
        /// </summary>
        public string RouteTemplate { get; set; }

        /// <summary>
        /// Route segment 1. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S1 { get; set; }

        /// <summary>
        /// Route segment 2. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S2 { get; set; }

        /// <summary>
        /// Route segment 3. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S3 { get; set; }

        /// <summary>
        /// Route segment 4. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S4 { get; set; }

        /// <summary>
        /// Route segment 5. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S5 { get; set; }

        /// <summary>
        /// Route segment 6. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S6 { get; set; }

        /// <summary>
        /// Route segment 7. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S7 { get; set; }

        /// <summary>
        /// Route segment 8. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S8 { get; set; }

        /// <summary>
        /// Route segment 9. Turned into <see cref="RouteSegmentClass"/> by <see cref="APIMethod.CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public object S9 { get; set; }

        /// <summary>
        /// <see cref="Request.CurrentUser"/> (<see cref="BaseEntity.AccessLevelGiven"/>) must by equal to <see cref="MethodAttribute.AccessLevelUse"/> or HIGHER in order for access to be granted to <see cref="APIMethod"/>
        /// </summary>
        public AccessLevel AccessLevelUse { get; set; } = AccessLevel.User;

        /// <summary>
        /// TRUE means that detailed result information like <see cref="Result.LogData"/> and <see cref="Result.Counts"/> 
        /// shall be returned to client. This is useful for instance for long duration complex methods where the (human) client usually wants to 
        /// understand what is going on internally in the API.
        /// </summary>
        public bool ShowDetailedResult { get; set; } = false;

        /// <summary>
        /// The current <see cref="Util.Configuration"/>.<see cref="Configuration.Environment"/> has to be equivalent or lower in order for the method to be included in the API routing
        /// </summary>
        public Environment Environment { get; set; } = Environment.Production;

        /// <summary>
        /// Note that you may set Description through either [Description("...")] or [AgoRapideAttribute(Description = "...")]. The last one takes precedence. 
        /// </summary>
        public string Description { get; set; }

        public string LongDescription { get; set; }

        /// <summary>
        /// TODO: Not inplemented as of Jan 2017
        /// 
        /// Next method that client is suggested to call. 
        /// Typical would be to suggest Person/{id} after doing Person/Add/{first_name}/{last_name} for instance. 
        /// <see cref="Result.ToHTMLDetailed"/> could add this, since it knows request, parameters and so on.
        /// Typical would be to replace {id} in this string with result values like <see cref="CoreProperty.Id"/>. 
        /// We could also add this to <see cref="Result.ToJSONDetailed"/>
        /// </summary>
        public string SuggestedNextMethod { get; set; }
    }
}
