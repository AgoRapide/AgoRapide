using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;

namespace AgoRapide.API {

    /// <summary>
    /// TODO: Add some kind of SuggestedNextMethod / SuggestedNextCommand, that will be automatically added in HTML-responses
    /// TODO: to client. We have a problem of mapping them though, but autogenerated methods could contain such a thing. 
    /// </summary>
    [Class(Description = "General attributes for a -" + nameof(APIMethod) + "-.")]
    public class APIMethodAttribute : BaseAttribute {

        public CoreAPIMethod CoreMethod { get; set; }
        public void AssertCoreMethod(CoreAPIMethod coreMethod) {
            if (CoreMethod != coreMethod) throw new InvalidEnumException(CoreMethod, "Expected " + coreMethod);
        }

        /// <summary>
        /// TODO: Implement support for <see cref="APIMethodAttribute.RouteTemplate"/>.
        /// </summary>
        public string RouteTemplate { get; set; }

        [ClassMember(Description = "Route segment 1. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S1 { get; set; }
        [ClassMember(Description = "Route segment 2. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S2 { get; set; }
        [ClassMember(Description = "Route segment 3. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S3 { get; set; }
        [ClassMember(Description = "Route segment 4. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S4 { get; set; }
        [ClassMember(Description = "Route segment 5. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S5 { get; set; }
        [ClassMember(Description = "Route segment 6. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S6 { get; set; }
        [ClassMember(Description = "Route segment 7. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S7 { get; set; }
        [ClassMember(Description = "Route segment 8. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S8 { get; set; }
        [ClassMember(Description = "Route segment 9. Turned into -" + nameof(RouteSegmentClass) + "- by -" + nameof(APIMethod.CreateSemiAutogeneratedMethods) + "-.")]
        public object S9 { get; set; }

        /// <summary>
        /// <see cref="Request.CurrentUser"/> (<see cref="BaseEntity.AccessLevelGiven"/>) must by equal to <see cref="APIMethodAttribute.AccessLevelUse"/> or HIGHER in order for access to be granted to <see cref="APIMethod"/>
        /// </summary>
        public AccessLevel AccessLevelUse { get; set; } = AccessLevel.User;

        /// <summary>
        /// TRUE means that detailed result information like <see cref="Result.LogData"/> and <see cref="Result.Counts"/> 
        /// shall be returned to client. This is useful for instance for long duration complex methods where the (human) client usually wants to 
        /// understand what is going on internally in the API.
        /// </summary>
        public bool ShowDetailedResult { get; set; } = false;

        /// <summary>
        /// The current <see cref="Util.Configuration"/>.<see cref="ConfigurationAttribute.Environment"/> has to be equivalent or lower in order for the method to be included in the API routing
        /// </summary>
        public Environment Environment { get; set; } = Environment.Production;

        /// <summary>
        /// TODO: Not inplemented as of Jan 2017
        /// 
        /// Next method that client is suggested to call. 
        /// Typical would be to suggest Person/{id} after doing Person/Add/{first_name}/{last_name} for instance. 
        /// <see cref="Result.ToHTMLDetailed"/> could add this, since it knows request, parameters and so on.
        /// Typical would be to replace {id} in this string with result values like <see cref="CoreP.Id"/>. 
        /// We could also add this to <see cref="Result.ToJSONDetailed"/>
        /// </summary>
        public string SuggestedNextMethod { get; set; }

        protected override Dictionary<CoreP, Property> GetProperties() {
            var retval = PropertiesParent;
            /// Note how we are not adding None-values since they will be considered invalid at later reading from database.
            /// Note how string value and <see cref="Property.ValueA"/> (<see cref="BaseAttribute"/>) are easily deduced by <see cref="PropertyT{T}"/> in this case so we do not need to add those as parameters here.
            if (CoreMethod != CoreAPIMethod.None) retval.AddProperty(CoreP.CoreAPIMethod.A(), CoreMethod);
            if (AccessLevelUse != AccessLevel.None) retval.AddProperty(CoreP.AccessLevelUse.A(), AccessLevelUse);
            if (Environment != Environment.None) retval.AddProperty(CoreP.Environment.A(), Environment);

            /// Note adding of string value and <see cref="Property.ValueA"/> (<see cref="BaseAttribute"/>) here
            retval.AddProperty(CoreP.Description.A(), Description + "", Description + "", GetType().GetClassMemberAttribute(nameof(Description))); // (TODO: Implement mechanism for setting no-longer-current of existing property instead (when this value becomes null))
            retval.AddProperty(CoreP.LongDescription.A(), LongDescription + "", LongDescription + "", GetType().GetClassMemberAttribute(nameof(LongDescription))); // (TODO: Implement mechanism for setting no-longer-current of existing property instead (when this value becomes null))
            retval.AddProperty(CoreP.ShowDetailedResult.A(), ShowDetailedResult, ShowDetailedResult.ToString(), GetType().GetClassMemberAttribute(nameof(ShowDetailedResult)));
            return retval.Properties;
        }
    }
}
