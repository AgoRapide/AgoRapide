// Copyright (c) 2016, 2017 Bjørn Erling Fløtten, Trondheim, Norway
// MIT licensed. Details at https://github.com/AgoRapide/AgoRapide/blob/master/LICENSE
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;
using System.Web.Http;
using AgoRapide.Database;
using AgoRapide.API;

namespace AgoRapide.API {

    /// <summary>
    /// TODO: Try to split into sub-classes for different <see cref="APIMethodOrigin"/> and also for <see cref="CoreAPIMethod.BaseEntityMethod"/>
    /// </summary>
    [Class(
        Description = "Represents one API method, like \"Person/Add/{first_name}/{last_name}\"",
        AccessLevelRead = AccessLevel.Anonymous,
        AccessLevelWrite = AccessLevel.System
    )]
    public class APIMethod : ApplicationPart {

        /// <summary>
        /// TODO: MOVE THIS INTO <see cref="APIMethodAttribute"/>
        /// </summary>
        public APIMethodOrigin Origin => PVM<APIMethodOrigin>();

        [ClassMember(Description =
            "Corresponds to  IHttpRoute.MapHttpRoute.defaults.Controller (although that one is without 'Controller' i the name).\r\n" +
            "Name of type is guaranteed to end with 'Controller'. " +
            "Not set for -" + nameof(APIMethodOrigin.Autogenerated) + "-")]
        public Type Controller { get; private set; }

        [ClassMember(
            Description =
                "The method in -" + nameof(Controller) + "- implementing the API functionality.\r\n" +
                "Corresponds to IHttpRoute.MapHttpRoute.defaults.Action.\r\n" +
                "Not set for -" + nameof(APIMethodOrigin.Autogenerated) + "-.",
            LongDescription =
                "Not to be confused with -" + nameof(BaseEntityMethod) + "- which is only relevant for -" + nameof(CoreAPIMethod.BaseEntityMethod) + "-"
        )]
        public System.Reflection.MethodInfo ControllerMethod { get; private set; }

        [ClassMember(
            Description =
                "The -" + nameof(BaseEntity) + "- method (method in -" + nameof(EntityType) + "-) implementing the API functionality. " +
                "Only relevant for -" + nameof(CoreAPIMethod.BaseEntityMethod) + "-.",
            LongDescription = "Not to be confused with -" + nameof(ControllerMethod) + "-."
        )]
        public System.Reflection.MethodInfo BaseEntityMethod { get; private set; }

        /// <summary>
        /// Exactly same instance as <see cref="ApplicationPart.A"/> 
        /// </summary>
        public APIMethodAttribute _ma { get; private set; }
        public APIMethodAttribute MA { get => _ma ?? throw new NullReferenceException(nameof(MA)); set => _ma = value ?? throw new NullReferenceException(nameof(value)); }

        private bool? _requiresAuthorization;
        public bool RequiresAuthorization => _requiresAuthorization ?? (bool)(_requiresAuthorization = PV<bool>(APIMethodP.RequiresAuthorization.A()));

        /// <summary>
        /// Dummy constructor for use by <see cref="BaseDatabase.TryGetEntityById"/>. 
        /// Object meant to be discarded immediately afterwards in <see cref="ApplicationPart.Get{T}"/>. 
        /// DO NOT USE!
        /// </summary>
        public APIMethod() : base(BaseAttribute.GetStaticNotToBeUsedInstance) { }

        /// <summary>
        /// Constructor used for <see cref="APIMethodOrigin.Autogenerated"/>-methods
        /// </summary>
        /// <param name="requiresAuthorization"></param>
        /// <param name="entityType">Not relevant for <see cref="CoreAPIMethod.Configuration"/></param>
        /// <param name="methodAttribute"></param>
        /// <param name="httpMethods"></param>
        /// <param name="routeSegments"></param>
        /// <param name="method">Only relevant for <see cref="CoreAPIMethod.BaseEntityMethod"/></param>
        private APIMethod(Type entityType, APIMethodAttribute methodAttribute, List<RouteSegmentClass> routeSegments, System.Reflection.MethodInfo baseEntityMethod, BaseDatabase db) : base(methodAttribute) {
            Util.AssertCurrentlyStartingUp();

            switch (methodAttribute.CoreMethod) {
                case CoreAPIMethod.Configuration:
                case CoreAPIMethod.Context: NotNullReferenceException.AssertNotNull(entityType); break; // TODO: Remove this!
                default: _entityType = entityType ?? throw new NullReferenceException(nameof(entityType)); break;
            }

            MA = methodAttribute ?? throw new NullReferenceException(nameof(methodAttribute));
            RouteSegments = routeSegments ?? throw new NullReferenceException(nameof(routeSegments));

            // Parameters = parameters ?? throw new NullReferenceException(nameof(parameters));
            Parameters = RouteSegments.Where(s => s.Parameter != null).Select(s => s.Parameter).ToList();

            // RouteTemplates = new List<string> { routeTemplate ?? throw new NullReferenceException(nameof(routeTemplate)) };
            RouteTemplates = new List<string> { string.Join("/", RouteSegments.Select(s => s.Template)) };

            switch (methodAttribute.CoreMethod) {
                case CoreAPIMethod.BaseEntityMethod: BaseEntityMethod = baseEntityMethod ?? throw new NullReferenceException(nameof(baseEntityMethod)); break;
                default: NotNullReferenceException.AssertNotNull(baseEntityMethod); break;
            }

            MA.SetId(GetId());
            ConnectWithDatabase(db);
        }

        /// <summary>
        /// Constructor used for <see cref="APIMethodOrigin.SemiAutogenerated"/>-methods
        /// </summary>
        /// <param name="controller"></param>
        /// <param name="controllerMethod"></param>
        /// <param name="methodAttribute"></param>
        /// <param name="httpMethods"></param>
        private APIMethod(Type controller, System.Reflection.MethodInfo controllerMethod, APIMethodAttribute methodAttribute, BaseDatabase db) : base(methodAttribute) {
            Util.AssertCurrentlyStartingUp();

            Controller = controller ?? throw new ArgumentNullException(nameof(controller));
            if (!Controller.ToStringShort().EndsWith("Controller")) throw new InvalidControllernameException("'" + controller.ToStringShort() + "' does not end with 'Controller'");
            InvalidTypeException.AssertAssignable(Controller, typeof(BaseController), null);
            ControllerMethod = controllerMethod ?? throw new ArgumentNullException(nameof(controllerMethod));
            MA = methodAttribute ?? throw new NullReferenceException(nameof(methodAttribute));

            var detailer1 = new Func<string>(() => "\r\nerrorDetails: " + ToString());

            RouteSegments = new List<RouteSegmentClass>(); /// Somewhat duplicate code for <see cref="APIMethodOrigin.SemiAutogenerated"/> and <see cref="CoreAPIMethod.BaseEntityMethod"/>
            if (MA.S1 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S1), MA.S1, detailer1));
            if (MA.S2 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S2), MA.S2, detailer1));
            if (MA.S3 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S3), MA.S3, detailer1));
            if (MA.S4 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S4), MA.S4, detailer1));
            if (MA.S5 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S5), MA.S5, detailer1));
            if (MA.S6 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S6), MA.S6, detailer1));
            if (MA.S7 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S7), MA.S7, detailer1));
            if (MA.S8 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S8), MA.S8, detailer1));
            if (MA.S9 != null) RouteSegments.Add(new RouteSegmentClass(nameof(MA.S9), MA.S9, detailer1));

            switch (MA.CoreMethod) {
                case CoreAPIMethod.RootIndex:
                case CoreAPIMethod.GenericMethod:
                    if (RouteSegments.Count > 0) throw new MethodAttributeInitialisationException(
                        nameof(RouteSegments) + " (like S1, S2, S3 ...) are not allowed for " + typeof(CoreAPIMethod) + "." + MA.CoreMethod + ". " +
                        nameof(RouteSegments) + ".Count: " + RouteSegments.Count + ". " +
                        detailer1.Result("Details: "));
                    if (!string.IsNullOrEmpty(MA.RouteTemplate)) throw new MethodAttributeInitialisationException(
                        nameof(MA.RouteTemplate) + " is not allowed for " + typeof(CoreAPIMethod) + "." + MA.CoreMethod + ". " +
                        nameof(MA.RouteTemplate) + ": " + MA.RouteTemplate + ". " +
                        (MA.CoreMethod == CoreAPIMethod.GenericMethod ? ("For " + MA.CoreMethod + " it will default to " + typeof(ConfigurationAttribute) + "." + nameof(ConfigurationAttribute.GenericMethodRouteTemplate) + " = " + Util.Configuration.C.GenericMethodRouteTemplate) : "") + ". " +
                        detailer1()); break;
                default:
                    break;// OK
            }

            if (!string.IsNullOrEmpty(MA.RouteTemplate)) {
                // TODO: Implement parsing of traditional WebAPI template
                throw new NotImplementedException(nameof(APIMethodAttribute) + "." + nameof(APIMethodAttribute.RouteTemplate) + ", " + detailer1());
            }

            Parameters = new List<PropertyKey>();

            if (RouteSegments.Count == 0) {
                switch (MA.CoreMethod) {
                    case CoreAPIMethod.RootIndex:
                        RouteTemplates = new List<string> { "" };
                        goto finished; // Initialization is now complete. 
                    case CoreAPIMethod.GenericMethod:
                        RouteTemplates = new List<string> { Util.Configuration.C.GenericMethodRouteTemplate }; // Usually "{*url}"
                        goto finished; // Initialization is now complete. 
                    default:
                        throw new MethodInitialisationException("No " + nameof(APIMethodAttribute) + "." + nameof(MA.RouteTemplate) + ", no " + nameof(RouteSegments) + " and unknown " + nameof(CoreAPIMethod) + " (" + MA.CoreMethod + "). Possible resolution: Remove attribute " + MA.GetType().ToString() + " if not needed" + detailer1());
                }
            }

            // Continue with setting RouteTemplates, Parameters and other values:
            var parameters = ControllerMethod.GetParameters().ToList();
            parameters.ForEach(p => {
                if (!p.ParameterType.Equals(typeof(string))) throw new InvalidObjectTypeException(p.ParameterType, "Parameter " + p.ToString() + ". All parameters must have type " + typeof(string) + detailer1());
            });
            // var routeTemplate = new System.Text.StringBuilder();

            var restParameters = parameters.ToDictionary(p => p.Name);
            // Check that ordering of parameters is the same, and that the names are equivalent
            RouteSegments.ForEach(s => {
                var detailer2 = new Func<string>(() => detailer1() + "\r\nRouteSegment: [" + MA.GetType().ToString() + "(" + s.SegmentName + ")]");

                if (s.Type != null) {
                    // routeTemplate.Append("/" + s.Type.ToStringVeryShort());
                    if (EntityType != null) throw new MethodInitialisationException(
                        "Duplicate type-definition\r\n" +
                        "(both " + s.Type + " and " + EntityType + " found)\r\n" +
                        // The first mistake (s.Type.IsEnum) is more common
                        (s.Type.IsEnum ? ("Did you write typeof(" + s.Type.ToStringShort() + ") when you really intended " + nameof(CoreP) + "." + s.Type.ToStringVeryShort() + "?\r\n") : "") +
                        // The second mistake (EntityType.IsEnum) less common
                        (EntityType.IsEnum ? ("Did you write typeof(" + EntityType.ToStringShort() + ") when you really intended " + nameof(CoreP) + "." + EntityType.ToStringVeryShort() + "?\r\n") : "") +
                        detailer2());
                    _entityType = s.Type;
                } else if (s.Parameter != null) {
                    var p = s.Parameter.Key;
                    if (p.A.Parents != null && EntityType != null && !p.HasParentOfType(EntityType)) throw new MethodInitialisationException(
                            "Incompatible types given for " +
                            p.GetType().ToString() + "-segment (" + EntityType + ") and " +
                            typeof(CoreP).ToString() + "." + p.CoreP.ToString() + " (" + p.A.Parents + ")\r\n" +
                            "You can not have " + typeof(CoreP).ToString() + "." + p.CoreP + " " +
                            "as parameter for operations involving entities of type " + EntityType + " " +
                            "because !" + nameof(p.HasParentOfType) + "(" + EntityType + ")" + detailer2());

                    if (restParameters.Count == 0) throw new MethodInitialisationException(
                        "Too few parameters defined in source code.\r\n" +
                        "Corresponding parameter " + p.A.EnumValueExplained + " for RouteSegment " +
                        "is missing for method " + ControllerMethod.Name + detailer2());
                    if (!restParameters.TryGetValue(p.PToString, out _)) throw new MethodInitialisationException(
                        "Corresponding parameter " + p.A.EnumValueExplained + " for RouteSegment " +
                        "is missing (or wrongly named) for method " + ControllerMethod.Name + ".\r\n" +
                        "Is one of the following mis-named: " + restParameters.KeysAsString() + "\r\n?\r\n" +
                        detailer2());
                    if (Parameters.Any(t => t.Key.CoreP.Equals(p.CoreP))) throw new MethodInitialisationException("Duplicate parameter " + typeof(CoreP).ToString() + "." + p.CoreP + " given" + detailer2());
                    Parameters.Add(s.Parameter);
                    restParameters.Remove(p.PToString);
                } else if (s.String != null) {
                    // ok
                } else {
                    throw new RouteSegmentClass.InvalidRouteSegmentClassException("Did not recognize any of the supposed required types" + detailer2());
                }
            });
            if (restParameters.Count > 0) throw new MethodInitialisationException("The following parameters does not have corresponding [" + MA.GetType().ToString() + "(Sx = " + typeof(CoreP).ToString() + ".yyy)] initialisations: " + string.Join(", ", restParameters.Keys) + detailer1);
            RouteTemplates = new List<string> { string.Join("/", RouteSegments.Select(s => s.Template)) };

            finished:

            MA.SetId(GetId());
            ConnectWithDatabase(db);
        }

        /// <summary>
        /// Consists of controller = Controller and action = MethodName
        /// </summary>
        public object Defaults {
            get {
                if (Origin == APIMethodOrigin.Autogenerated) throw new InvalidEnumException(Origin, ToString());
                return new {
                    controller = Controller.ToStringShort().Replace("Controller", ""),
                    action = ControllerMethod.Name
                };
            }
        }

        /// <summary>
        /// TODO: Turn this into a single string since overloads are now handled by the 
        /// TODO: <see cref="BaseController.AgoRapideGenericMethod"/> concept.
        /// 
        /// Guaranteed always set with at least one value (but for <see cref="CoreAPIMethod.RootIndex"/> the value will usually be empty)
        /// 
        /// REST URL syntax as used by Microsoft .NET WebAPI like Person/Add/{first_name}/{last_name}
        /// For <see cref="CoreAPIMethod.GenericMethod"/> it is usually {*url} 
        /// 
        /// Note that <see cref="Util.Configuration"/>.<see cref="ConfigurationAttribute.APIPrefix"/> (normally "api/") is not present here. 
        /// It is added later by <see cref="APIMethodMapper.MapHTTPRoutes"/>
        /// </summary>
        public List<string> RouteTemplates { get; private set; }

        /// <summary>
        /// Inserts <paramref name="parameters"/> into <see cref="RouteTemplates"/> according to <see cref="PropertyKeyAttributeEnriched.ConvertObjectToString"/>
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GetAPICommand(params object[] parameters) {
            if (parameters.Length != Parameters.Count) throw new InvalidCountException(nameof(parameters) + ".Length (" + parameters.Length + ") != " + nameof(Parameters) + ".Count (" + Parameters.Count + ") for " + ToString());
            var retval = RouteTemplates[0];
            for (var i = 0; i < parameters.Length; i++) {
                if (Parameters.Count <= i) return retval;
                var key = "{" + Parameters[i].Key.PToString + "}";
                var next = retval.Replace(key, Parameters[i].Key.ConvertObjectToString(parameters[i]));
                if (next.Equals(retval)) throw new MethodInitialisationException(key + " not found for " + ToString());
                retval = next;
            }
            return retval;
        }

        private string _toString;
        /// <summary>
        /// Try to set Origin and Controller / ControllerMethod in a more orderly fashion, so we can remove some
        /// unnecessary checks here (especially origin)
        /// </summary>
        /// <returns></returns>
        public override string ToString() => _toString ?? (_toString =
            base.ToString() + ",\r\n" +
            (Properties != null && Properties.ContainsKey(APIMethodP.APIMethodOrigin.A().Key.CoreP) ? (Origin.ToString() + ", ") : "") +
            (RouteTemplates != null && RouteTemplates.Count > 0 ? (RouteTemplates[0] + ", ") : "") +
            (Controller != null ? (Controller.ToStringShort() + ".") : "") +
            (ControllerMethod != null ? (ControllerMethod.Name + ", ") : "") +
            (MA != null && MA.CoreMethod != CoreAPIMethod.None ? (nameof(CoreAPIMethod) + "." + MA.CoreMethod) : ""));

        public class MethodInitialisationException : ApplicationException {
            public MethodInitialisationException(string message) : base(message) { }
        }

        public class InvalidRouteTemplateException : ApplicationException {
            public InvalidRouteTemplateException(string message) : base(message) { }
        }

        /// <summary>
        /// TODO: MOVE TO SEPARATE DOCUMENTATOR CLASS!
        /// 
        /// Inserts HTML links to methods within the HTML given
        /// See also InsertDocumentationURLs 
        /// </summary>
        /// <param name="html">
        /// Tip: Use the shortest route templates, like -Person/Add- since the documentation URL is the same for all overloads.
        /// </param>
        /// <returns></returns>
        public static string InsertDocumentationHTMLLinks(string html) {
            if (string.IsNullOrEmpty(html)) return html;
            throw new NotImplementedException();
            // AllMethods.ForEach(r => r.RouteTemplates.ForEach(template => html = html.Replace("-" + template + "-", r.DocumentationLink)));
        }

        /// <summary>
        /// TODO: MOVE TO SEPARATE DOCUMENTATOR CLASS!
        /// 
        /// Inserts URL to methods into text. 
        /// See also InsertDocumentationHTMLLinks
        /// 
        /// All occurrences of route templates like -Person/Add- or -Person/Add/{first_name}- will be
        /// replaced with a URL to that method's corresponding documentation.
        /// </summary>
        /// <param name="text">
        /// Tip: Use the shortest route templates, like -Person/Add- since the documentation URL is the same for all overloads.        /// </param>
        /// <returns></returns>
        public static string InsertDocumentationURLs(string text) => throw new NotImplementedException();

        private Type _entityType;
        public Type EntityType => _entityType ?? (_entityType = TryGetPV<Type>(CoreP.EntityType.A(), out var retval) ? retval : null); // Set in-memory, later read from database

        public List<PropertyKey> Parameters { get; private set; }

        /// <summary>
        /// Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// </summary>
        protected static List<APIMethod> _allMethods = null;
        /// <summary>
        /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
        /// </summary>
        public static List<APIMethod> AllMethods => _allMethods ?? throw new NullReferenceException(nameof(_allMethods) + ", Call " + nameof(CreateSemiAutogeneratedMethods) + " first");

        /// <summary>
        /// Methods ignored because <see cref="APIMethodAttribute.Environment"/> does not match current <see cref="ConfigurationAttribute.Environment"/>
        /// </summary>
        public static List<APIMethod> IgnoredMethods = new List<APIMethod>();

        /// <summary>
        /// Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// Key is <see cref="BaseEntity.IdFriendly"/> which again is set as method.Controller.ToStringShort() + "." + method.ControllerMethod.Name
        /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
        /// </summary>
        protected static Dictionary<string, APIMethod> _allMethodsByControllerAndMethodName;

        public static APIMethod GetByControllerAndMethodName(Type controller, string controllerMethodName) => TryGetByControllerAndMethodName(controller, controllerMethodName, out var retval) ? retval : throw new MethodNotFoundException("Method '" + controller + "." + controllerMethodName + "' not found");
        public static bool TryGetByControllerAndMethodName(Type controller, string controllerMethodName, out APIMethod method) {
            var dummy = AllMethods;
            return _allMethodsByControllerAndMethodName.TryGetValue(controller.ToStringShort() + "." + controllerMethodName, out method);
        }

        public static APIMethod GetByCoreMethodAndEntityType(CoreAPIMethod coreMethod, Type entityType) => TryGetByCoreMethodAndEntityType(coreMethod, entityType, out var retval) ? retval : throw new MethodNotFoundException(coreMethod, entityType,
            !typeof(BaseEntity).IsAssignableFrom(entityType) ?
            ("Possible cause: " + entityType + " does not inherit " + nameof(BaseEntity) + ".") :
            ("Possible resolution: Check " + nameof(ClassAttribute) + " " + nameof(ClassAttribute.AccessLevelRead) + " / " + nameof(ClassAttribute.AccessLevelWrite) + " set for " + entityType + ". Current values are " + entityType.GetClassAttribute().AccessLevelRead + " / " + entityType.GetClassAttribute().AccessLevelWrite + ". (" + nameof(APIMethodOrigin.Autogenerated) + " API methods are not generated for " + AccessLevel.System + " or higher.)")
        );
        protected static ConcurrentDictionary<string, APIMethod> _allMethodsByCoreMethodAndEntityType = new ConcurrentDictionary<string, APIMethod>();
        /// <summary>
        /// 
        /// </summary>
        /// <param name="coreMethod"></param>
        /// <param name="entityType">May be null, for instance for <see cref="CoreAPIMethod.ExceptionDetails"/></param>
        /// <param name="method"></param>
        /// <returns></returns>
        public static bool TryGetByCoreMethodAndEntityType(CoreAPIMethod coreMethod, Type entityType, out APIMethod method) => (method = _allMethodsByCoreMethodAndEntityType.GetOrAdd(coreMethod.ToString() + "_" + (entityType?.ToString() ?? ""), k => {
            if (entityType != null && typeof(Property).IsAssignableFrom(entityType)) entityType = typeof(Property); /// This adjustment is necessary in cases where entityType is an instance of <see cref="PropertyT{T}"/>.
            //if (entityType != null && CoreMethod.EntityIndex.Equals(coreMethod)) {
            //    coreMethod = CoreMethod.Configuration;
            //    entityType = null; /// Typical example when <see cref="Property"/> uses <see cref="Property.Parent"/> in order to create link to the parent
            //}
            return AllMethods.SingleOrDefault(m => m.MA.CoreMethod == coreMethod && ((entityType == null && m.EntityType == null) || (entityType != null && entityType.Equals(m.EntityType))), () => nameof(coreMethod) + ": " + coreMethod + ", " + nameof(entityType) + ": " + (entityType?.ToStringShort() ?? "[NULL]"));
        })) != null;

        /// <summary>
        /// This consists of the values for <see cref="APIMethodAttribute.S1"/> to <see cref="APIMethodAttribute.S9"/>. Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public List<RouteSegmentClass> RouteSegments { get; private set; }

        private static HashSet<Type> _allEntityTypes;
        /// <summary>
        /// </summary>
        /// <param name="clientAssemblies">
        /// Used to look for <see cref="AgoRapide.BaseEntity"/>-derived class in your project. 
        /// Do not include assembly where <see cref="BaseEntity"/> resides as that is included automatically
        /// </param>
        /// <param name="exclude">
        /// Types to exclude. You might want to exclude <see cref="Person"/> as that class is provided only out of convenience.
        /// 
        /// In addition to types given here the following will also be excluded:
        /// All <see cref="Type.IsGenericTypeDefinition"/>
        /// All <see cref="Type.IsAbstract"/>
        /// <see cref="BaseEntity"/>
        /// </param>
        [ClassMember(Description =
            "Adds all -" + nameof(BaseEntity) + "- types found in the given assemblies to -" + nameof(APIMethod.AllEntityTypes) + "-. "
        )]
        public static void SetEntityTypes(IEnumerable<System.Reflection.Assembly> clientAssemblies, IEnumerable<Type> exclude) {
            Util.AssertCurrentlyStartingUp();
            var assemblies = clientAssemblies.ToList(); assemblies.Add(typeof(BaseEntity).Assembly);
            _allEntityTypes = new HashSet<Type>();
            assemblies.SelectMany(a => a.GetTypes()).Where(t => {
                if (!typeof(BaseEntity).IsAssignableFrom(t)) return false;
                if (t.IsGenericTypeDefinition) return false;
                if (t.IsAbstract) return false; /// Typically <see cref="ApplicationPart"/>, <see cref="APIDataObject"/>, <see cref="BaseSynchronizer"/>
                if (t.Equals(typeof(BaseEntity))) return false; /// Note how this is not abstract. See else comment for <see cref="_allEntityTypes"/>, do not include <see cref="BaseEntity"/>                
                return true;
            }).ForEach(t => {
                if (t.Equals(typeof(BaseEntity))) throw new InvalidTypeException(t, "Not needed in " + nameof(AllEntityTypes) + " collection");
                if (_allEntityTypes.Contains(t)) throw new InvalidTypeException(t, "Already contained in " + nameof(_allEntityTypes));
                _allEntityTypes.Add(t);
            });
        }

        [ClassMember(
            Description =
                "All relevant -" + nameof(BaseEntity) + "--types.\r\n" +
                "Note how -" + nameof(BaseEntity) + "- is NOT included in this collection.",
            LongDescription =
                "Set by -" + nameof(SetEntityTypes) + "-."
        )]
        public static HashSet<Type> AllEntityTypes { get => _allEntityTypes ?? throw new NullReferenceException(nameof(_allEntityTypes)); }

        protected static Dictionary<string, APIMethod> _allMethodsByRouteTemplate;
        /// <summary>
        /// Constructs <see cref="APIMethodOrigin.SemiAutogenerated"/>-methods.
        /// 
        /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database)
        /// TODO: One approach could be to do <see cref="PropertyOperation.SetInvalid"/> for those methods with old value in <see cref="DBField .valid"/>
        /// TODO: after initialization of application.
        /// </summary>
        /// <param name="controllers"></param>
        /// <param name="attributeClassesSignifyingRequiresAuthorization">
        /// Used to set <see cref="APIMethod.RequiresAuthorization"/>.
        /// Typical values would be type of <see cref="System.Web.Http.AuthorizeAttribute"/> or 
        /// your own types like AgoRapideSample.BasicAuthenticationAttribute
        /// </param>
        /// <returns></returns>
        public static void CreateSemiAutogeneratedMethods(List<Type> controllers, List<Type> attributeClassesSignifyingRequiresAuthorization, BaseDatabase db) {
            Util.AssertCurrentlyStartingUp();
            _allMethods = new List<APIMethod>();
            controllers.ForEach(controller => {
                InvalidTypeException.AssertAssignable(controller, typeof(BaseController), null);
                controller.GetMethods().ForEach(methodInfo => {
                    var ma = Attribute.GetCustomAttribute(methodInfo, typeof(APIMethodAttribute)) as APIMethodAttribute;
                    if (ma == null) return; // OK, just ignore this method
                    var detailer1 = new Func<string>(() => ". errorDetails: " + controller.ToString() + "." + methodInfo.Name);
                    UpdateInDataseThenFilterOrAddMethod(
                        APIMethodOrigin.SemiAutogenerated,
                        requiresAuthorization: attributeClassesSignifyingRequiresAuthorization.Any(t => null != Attribute.GetCustomAttribute(methodInfo, t)),
                        httpMethods: new Func<List<HTTPMethod>>(() => {
                            var r = new List<HTTPMethod>();
                            if (null != Attribute.GetCustomAttribute(methodInfo, typeof(HttpGetAttribute))) r.Add(HTTPMethod.GET);
                            if (null != Attribute.GetCustomAttribute(methodInfo, typeof(HttpPostAttribute))) r.Add(HTTPMethod.POST);
                            // DELETE and PUT may be added if desired.
                            return r;
                        })(),
                        method: new APIMethod(
                            controller: controller,
                            controllerMethod: methodInfo,
                            methodAttribute: ma,
                            db: db
                        ),
                        db: db
                    );
                });
            });
            _allMethods.ForEach(r => { // Assert valid RouteTemplates since they are set multiple places above:
                if (r.RouteTemplates == null) throw new MethodInitialisationException(nameof(RouteTemplates) + " == null for " + r.ToString());
                if (r.RouteTemplates.Count == 0) throw new MethodInitialisationException(nameof(RouteTemplates) + ".Count == 0 for " + r.ToString());
                r.RouteTemplates.ForEach(rt => {
                    if (rt == null) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " == null for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                    if (rt.Contains("//")) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " (" + rt + ") Contains (\"//\") for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                    if (rt.StartsWith("/")) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " (" + rt + ") StartsWith(\"/\") for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                });

            });

            /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
            _allMethodsByControllerAndMethodName = new Dictionary<string, APIMethod>();
            _allMethodsByRouteTemplate = new Dictionary<string, APIMethod>();
            _allMethods.ForEach(m => {
                _allMethodsByControllerAndMethodName.AddValue(m.PV<string>(APIMethodP.ImplementatorIdFriendly.A()), m, () => "Duplicate " + nameof(APIMethodP.ImplementatorIdFriendly) + " (" + m.PV<string>(APIMethodP.ImplementatorIdFriendly.A()) + ") has already been added to collection " + nameof(_allMethodsByControllerAndMethodName));
                _allMethodsByRouteTemplate.AddValue(m.RouteTemplates[0], m, () => "Duplicate " + nameof(m.RouteTemplates) + "[0] (" + m.RouteTemplates[0] + ") has already been added to collection " + nameof(_allMethodsByRouteTemplate));
            });
        }

        /// <summary>
        /// Constructs <see cref="APIMethodOrigin.Autogenerated"/>-methods.        
        /// Adds these to <see cref="AllMethods"/>. 
        /// 
        /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database)
        /// TODO: One approach could be to do <see cref="PropertyOperation.SetInvalid"/> for those methods with old value in <see cref="DBField .valid"/>
        /// TODO: after initialization of application.
        /// 
        /// TODO: As of Oct 2017 this is a little slow on startup (uses several seconds). 
        /// </summary>
        /// <param name="types">
        /// List of entities for which client wants standardised methods like Person/{id}, Person/{id}/AddProperty/{key}/{value}
        /// </param>
        public static void CreateAutogeneratedMethods(BaseDatabase db) {
            Util.AssertCurrentlyStartingUp();
            if (_allMethods == null) throw new NullReferenceException(nameof(_allMethods) + ". Resolution: " + nameof(CreateSemiAutogeneratedMethods) + " must be called before " + nameof(CreateAutogeneratedMethods));

            var connector = new Action<bool, APIMethod>((requiresAuthorization, method) => {
                /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database
                /// TODO: no longer relevant since ConnectMethodWithDatabase is not called for them)
                if (_allMethodsByRouteTemplate.TryGetValue(method.RouteTemplates[0], out var existing)) throw new MethodInitialisationException(
                    method.RouteTemplates[0] + " is already implemented by " + existing.PV<string>(APIMethodP.ImplementatorIdFriendly.A()) + ".\r\n" +
                    "You must either remove that implementation or remove type " + method.EntityType.ToStringShort() + " as parameter to " + System.Reflection.MethodBase.GetCurrentMethod().Name + ".\r\n" +
                    "Details for existing method: " + existing.ToString() + ".\r\n" +
                    "Details for " + APIMethodOrigin.Autogenerated + " method: " + method.ToString());
                UpdateInDataseThenFilterOrAddMethod(APIMethodOrigin.Autogenerated, requiresAuthorization, new List<HTTPMethod> { HTTPMethod.GET }, method, db);
            });

            /// Creates <see cref="CoreAPIMethod.AddEntity"/> like Person/Add/{email}/{password}
            var addEntityCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.AddEntity + " attempt for " + t.ToStringDB());
                var obligatoryParameters = t.GetObligatoryChildProperties();
                var routeSegments = new List<RouteSegmentClass> {
                    new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                    new RouteSegmentClass("Add", "Add", detailer),
                };
                obligatoryParameters.ForEach(p => routeSegments.Add(new RouteSegmentClass(p.Value.Key.PToString, p.Value, detailer)));
                connector(
                    true,  /// <see cref="APIMethodP.RequiresAuthorization"/>
                    new APIMethod(
                        entityType: t,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.AddEntity,
                            Description =
                                "Adds an entity of type -" + t.ToStringShort() + "-.",
                            AccessLevelUse = t.GetClassAttribute().AccessLevelWrite // Use of method equals writing of entity (creation)
                        },
                        routeSegments: routeSegments,
                        baseEntityMethod: null,
                        db: db
                    )
               );
            });

            /// Creates <see cref="CoreAPIMethod.EntityIndex"/> like Person/{id}
            var entityIndexCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.EntityIndex + " attempt for " + t.ToStringDB());
                connector(
                    /// <see cref="APIMethodP.RequiresAuthorization"/>
                    // TODO: Create a configuration parameter deciding whether API-documentation should be available without authorization.
                    // TODO: We could also change this between production and test, for instance tightening down access to 
                    // TODO: API-documentation in test, while having anonymous access in production, hiding new features until launched.
                    !typeof(ApplicationPart).IsAssignableFrom(t), /// Note how <see cref="ApplicationPart"/> like <see cref="ClassMember"/>, <see cref="EnumValue"/> and <see cref="APIMethod"/> can be read-accessed (queried) without authorization (that is, the API documentation is common available)
                    new APIMethod(
                        entityType: t,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.EntityIndex,
                            Description = "Shows entities of type -" + t.ToStringShort() + "- as identified by {" + CoreP.QueryId + "}.",
                            AccessLevelUse = t.Equals(typeof(BaseEntity)) ?

                                /// NOTE: SOME entities may have <see cref="AccessLevel.Anonymous"/> and therefore the method itself must be 
                                /// NOTE: available for <see cref="AccessLevel.Anonymous"/>. The rationale is that we want to be able to link with
                                /// NOTE: api/Entity/{QueryId} whenever we see a <see cref="CoreP.DBId"/>-property without knowing what type of entity it is.
                                /// ----
                                /// TODO: Complete <see cref="BaseDatabase.TryVerifyAccess"/> in order for this to not be a security problem.
                                /// ----
                                /// NOTE: As of Apr 2017 similar exception has not been made for other <see cref="CoreAPIMethod"/>.
                                AccessLevel.Anonymous :

                                // In all other cases use of method equals reading of entity and we can se access equivalent to that set for the entity class
                                t.GetClassAttribute().AccessLevelRead
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                            new RouteSegmentClass(CoreP.QueryId.ToString(), CoreP.QueryId , detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            });

            /// Creates <see cref="CoreAPIMethod.UpdateProperty"/> like Person/{id}/AddProperty/{id}/{value]
            var updatePropertyCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.UpdateProperty + " attempt for " + t.ToStringDB());
                connector(
                    true,  /// <see cref="APIMethodP.RequiresAuthorization"/>
                    new APIMethod(
                        entityType: t,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.UpdateProperty,
                            Description = "Adds property for entities of type -" + t.ToStringShort() + "- as identified by {" + CoreP.QueryId + "}.",
                            AccessLevelUse = t.GetClassAttribute().AccessLevelWrite // Use of method equals writing to entity
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                            new RouteSegmentClass(nameof(CoreP.QueryId), CoreP.QueryId , detailer),
                            new RouteSegmentClass(CoreAPIMethod.UpdateProperty.ToString(), CoreAPIMethod.UpdateProperty.ToString(), detailer),
                            new RouteSegmentClass(nameof(CoreP.Key), CoreP.Key , detailer),
                            new RouteSegmentClass(nameof(CoreP.Value), CoreP.Value , detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            });

            /// Creates <see cref="CoreAPIMethod.PropertyOperation"/> like Person/{id}/AddProperty/{id}/{value]
            var propertyOperationCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.PropertyOperation + " attempt for " + t.ToStringDB());
                connector(
                    true,  /// <see cref="APIMethodP.RequiresAuthorization"/>
                    new APIMethod(
                        entityType: t,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.PropertyOperation,
                            Description = "Operates on property as identified by {" + CoreP.QueryId + "} with {" + nameof(PropertyOperation) + "} one of " + string.Join(", ", Util.EnumGetValues<PropertyOperation>()) + ".",
                            AccessLevelUse = t.GetClassAttribute().AccessLevelWrite // Use of method equals writing to entity
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                            new RouteSegmentClass(nameof(CoreP.QueryId), CoreP.QueryId , detailer),
                            new RouteSegmentClass(nameof(CoreP.PropertyOperation), CoreP.PropertyOperation , detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            });

            /// Creates <see cref="CoreAPIMethod.History"/> like Person/{id}/History and Person/{id}/History
            var historyCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.History + " attempt for " + t.ToStringDB());
                connector(
                    true,  /// <see cref="APIMethodP.RequiresAuthorization"/>
                    new APIMethod(
                        entityType: t,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.History,
                            Description =
                                "Shows history for entity of type -" + t.ToStringShort() + "- identified by {" + CoreP.QueryIdInteger + "}.",
                            AccessLevelUse = t.GetClassAttribute().AccessLevelRead // Use of method equals writing to entity
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                            new RouteSegmentClass(nameof(CoreP.QueryIdInteger), CoreP.QueryIdInteger , detailer),
                            new RouteSegmentClass(nameof(CoreAPIMethod.History), CoreAPIMethod.History.ToString() , detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            });

            /// Creates <see cref="CoreAPIMethod.Configuration"/>
            {
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.Configuration);
                connector(
                    /// <see cref="APIMethodP.RequiresAuthorization"/>
                    // TODO: Create a configuration parameter deciding whether API-documentation should be available without authorization.
                    // TODO: We could also change this between production and test, for instance tightening down access to 
                    // TODO: API-documentation in test, while having anonymous access in production, hiding new features until launched.
                    true,
                    new APIMethod(
                        entityType: null,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.Configuration,
                            Description = CoreAPIMethod.Configuration.GetEnumValueAttribute().Description,
                            AccessLevelUse = AccessLevel.Admin
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(CoreAPIMethod.Configuration.ToString(), CoreAPIMethod.Configuration.ToString(), detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            }

            var types = AllEntityTypes.ToList(); types.Add(typeof(BaseEntity));
            types.ForEach(t => {
                InvalidTypeException.AssertAssignable(t, typeof(BaseEntity), null);
                var a = t.GetClassAttribute();
                if (
                    !t.IsAbstract &&
                    !typeof(BaseEntity).Equals(t) &&
                    !typeof(Property).IsAssignableFrom(t) && // "Independent" properties would be a meaningless concept
                    a.AccessLevelWrite < AccessLevel.System) addEntityCreator(t);
                if (a.AccessLevelRead < AccessLevel.System || typeof(BaseEntity).Equals(t)) entityIndexCreator(t);
                if (a.AccessLevelRead < AccessLevel.System) historyCreator(t); // Must appear before addPropertyCreator
                if (a.AccessLevelWrite < AccessLevel.System) updatePropertyCreator(t);
                if (a.AccessLevelWrite < AccessLevel.System) propertyOperationCreator(t);

                /// Create <see cref="CoreAPIMethod.BaseEntityMethod"/>
                t.GetMethods().ForEach(methodInfo => {
                    var ma = Attribute.GetCustomAttribute(methodInfo, typeof(APIMethodAttribute)) as APIMethodAttribute;
                    if (ma == null) return; // OK, just ignore this method
                    var detailer1 = new Func<string>(() => ". errorDetails: " + t.ToString() + "." + methodInfo.Name);

                    connector(
                        true,  /// <see cref="APIMethodP.RequiresAuthorization"/>
                        new APIMethod(
                            entityType: t,
                            methodAttribute: new Func<APIMethodAttribute>(() => {
                                var retval = new APIMethodAttribute {
                                    CoreMethod = CoreAPIMethod.BaseEntityMethod,
                                    Description = ma.Description,
                                    LongDescription = ma.LongDescription,
                                    AccessLevelUse = ma.AccessLevelUse,
                                    Environment = ma.Environment,
                                    ShowDetailedResult = ma.ShowDetailedResult,
                                    S1 = t,
                                    S2 = CoreP.QueryId,
                                    S3 = ma.S1,
                                    S4 = ma.S2,
                                    S5 = ma.S3,
                                    S6 = ma.S4,
                                    S7 = ma.S5,
                                    S8 = ma.S6,
                                    S9 = ma.S7,
                                };
                                if (ma.S8 != null) throw new NotNullReferenceException("Too many parameters defined for " + t + "." + methodInfo.Name);
                                if (ma.S9 != null) throw new NotNullReferenceException("Too many parameters defined for " + t + "." + methodInfo.Name);
                                return retval;
                            })(),

                            routeSegments: new Func<List<RouteSegmentClass>>(() => {
                                var retval = new List<RouteSegmentClass>() { /// Somewhat duplicate code for <see cref="APIMethodOrigin.SemiAutogenerated"/> and <see cref="CoreAPIMethod.BaseEntityMethod"/>
                                    new RouteSegmentClass(t.ToStringVeryShort(), t, detailer1),
                                    new RouteSegmentClass(nameof(CoreP.QueryId), CoreP.QueryId, detailer1)
                                };
                                if (ma.S1 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S3), ma.S1, detailer1));
                                if (ma.S2 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S4), ma.S2, detailer1));
                                if (ma.S3 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S5), ma.S3, detailer1));
                                if (ma.S4 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S6), ma.S4, detailer1));
                                if (ma.S5 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S7), ma.S5, detailer1));
                                if (ma.S6 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S8), ma.S6, detailer1));
                                if (ma.S7 != null) retval.Add(new RouteSegmentClass(nameof(APIMethodAttribute.S9), ma.S7, detailer1));
                                if (ma.S8 != null) throw new NotNullReferenceException("Too many parameters defined for " + t + "." + methodInfo.Name);
                                if (ma.S9 != null) throw new NotNullReferenceException("Too many parameters defined for " + t + "." + methodInfo.Name);
                                return retval;
                            })(),
                            baseEntityMethod: methodInfo,
                            db: db
                        )
                    );
                });
            });

            /// Create <see cref="CoreAPIMethod.Context"/>
            {
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreAPIMethod.Context);
                connector(
                    true,
                    new APIMethod(
                        entityType: null,
                        methodAttribute: new APIMethodAttribute {
                            CoreMethod = CoreAPIMethod.Context,
                            Description = CoreAPIMethod.Context.GetEnumValueAttribute().Description,
                            AccessLevelUse = AccessLevel.User
                        },
                        routeSegments: new List<RouteSegmentClass> {
                            new RouteSegmentClass(CoreAPIMethod.Context.ToString(), CoreAPIMethod.Context.ToString(), detailer)
                        },
                        baseEntityMethod: null,
                        db: db
                    )
                );
            }
        }

        [ClassMember(
            Description = "Sets -" + nameof(APIMethodP.ImplementatorId) + "- for -" + nameof(AllMethods) + "-."
        )]
        public static void SetImplementatorIdAndCompleteAllEntityTypes(BaseDatabase db) {
            var cid = GetClassMember(System.Reflection.MethodBase.GetCurrentMethod(), db).Id;
            var classMembers = ApplicationPart.AllApplicationParts.Where(e => e.Value is ClassMember).Select(e => (ClassMember)e.Value).ToList();
            AllMethods.ForEach(method => {
                void updater<T>(PropertyKey key, T value) { // Bug with auto formatting (CTRL-K, D)? Brace is not correct placed
                    db.UpdateProperty(cid, method, key, value, result: null, SkipSetValid: TimeSpan.FromDays(1)); // Use of SkipSetValid reduces startup time of application, especially useful when developing.
                }
                var idFriendly = method.PV<string>(APIMethodP.ImplementatorIdFriendly.A());
                var implementator = classMembers.FirstOrDefault(c => c.IdFriendly.Equals(idFriendly));
                if (implementator == null) {
                    /// This might be caused by the class member not having any <see cref="ClassMemberAttribute"/>. Consider as OK.
                    // throw new NullReferenceException(nameof(APIMethodP.ImplementatorId) + " corresponding to " + nameof(APIMethodP.ImplementatorIdFriendly) + " '" + idFriendly + "' not found for " + m.ToString());
                } else {
                    updater(APIMethodP.ImplementatorId.A(), implementator.Id);
                }
            });
        }

        private Id GetId() {
            switch (MA.CoreMethod) {
                case CoreAPIMethod.RootIndex:
                    return new Id(
                        idString: new QueryIdString(MA.GetType().ToStringShort().Replace("Attribute", "") + "_" + MA.CoreMethod.ToString()),
                        idFriendly: "(" + MA.CoreMethod + ")", /// <see cref="APIMethod.RouteTemplates"/> can not be used as it is empty
                        idDoc: new List<string> { "(" + MA.CoreMethod + ")" }
                    );
                case CoreAPIMethod.GenericMethod:
                    return new Id(
                        idString: new QueryIdString(MA.GetType().ToStringShort().Replace("Attribute", "") + "_" + MA.CoreMethod.ToString()),
                        idFriendly: RouteTemplates[0],
                        idDoc: new List<string> { RouteTemplates[0] } // Most probably little useful
                    );
                default:
                    return new Id(
                        idString: new QueryIdString(MA.GetType().ToStringShort().Replace("Attribute", "") + "_" + RouteTemplates[0].Replace("/", "_").Replace("{", "_").Replace("}", "_")),
                        idFriendly: RouteTemplates[0],
                        idDoc: new List<string> { RouteTemplates[0] } // Most probably little useful
                    );
            }
        }

        /// <summary>
        /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database
        /// TODO: no longer relevant since ConnectMethodWithDatabase is not called for them)
        /// </summary>
        /// <param name="method"></param>
        /// <param name="db"></param>
        [ClassMember(Description =
                "1) Updates database.\r\n" +
                "2) Filters (ignores) if -" + nameof(APIMethodAttribute.Environment) + "- " +
                "   does not match -" + nameof(ConfigurationAttribute.Environment) + "- " +
                "   (but adds to -" + nameof(IgnoredMethods) + "- first).\r\n" +
                "3) Adds to -" + nameof(_allMethods) + "- (if not filtered out).")]
        private static void UpdateInDataseThenFilterOrAddMethod(APIMethodOrigin origin, bool requiresAuthorization, List<HTTPMethod> httpMethods, APIMethod method, BaseDatabase db) {
            Util.AssertCurrentlyStartingUp();

            if (method == null) throw new NullReferenceException(nameof(method));
            if (db == null) throw new NullReferenceException(nameof(db));

            // Moved to end. We want to update database anyway.
            //if (method.MA.Environment < Util.Configuration.C.Environment) {
            //    IgnoredMethods.Add(method);
            //    return;
            //}
            var cid = GetClassMember(System.Reflection.MethodBase.GetCurrentMethod(), db).Id;

            method.A.AssertToBeUsed();

            if (method.Properties == null) method.Properties = new ConcurrentDictionary<CoreP, Property>();

            void updater<T>(PropertyKey key, T value) { // Bug with auto formatting (CTRL-K, D)? Brace is not correct placed
                db.UpdateProperty(cid, method, key, value, result: null, SkipSetValid: TimeSpan.FromDays(1)); // Use of SkipSetValid reduces startup time of application, especially useful when developing.
            }

            if (method._entityType != null) {
                updater(CoreP.EntityType.A(), method._entityType);
                updater(CoreP.EntityTypeVeryShort.A(), method._entityType.ToStringVeryShort());
                updater(CoreP.EntityTypeCategory.A(), method._entityType.ToEntityTypeCategory());
            }

            updater(APIMethodP.APIMethodOrigin.A(), origin);
            updater(APIMethodP.RequiresAuthorization.A(), requiresAuthorization);
            updater(APIMethodP.RouteTemplate.A(), method.RouteTemplates[0]);
            updater(APIMethodP.HTTPMethods.A(), httpMethods);
            updater(APIMethodP.ImplementatorIdFriendly.A(), new Func<string>(() => {
                switch (method.PVM<APIMethodOrigin>()) {
                    case APIMethodOrigin.Autogenerated: return nameof(BaseController) + ".HandleCoreMethod" + method.MA.CoreMethod;
                    default: return method.Controller.ToStringShort() + "." + method.ControllerMethod.Name;
                }
            })());

            updater(APIMethodP.RequiresAuthorization.A(), method.PV<bool>(APIMethodP.RequiresAuthorization.A()));

            /// Construct sample URLs based on <see cref="PropertyKeyAttribute.SampleValues"/> for each parameter. 
            /// Permutate between all combinations
            /// TODO: Add check for <see cref="CoreP.Key"/> and only suggest <see cref="CoreP.Value"/>, 
            /// TODO: that are valid for the given key.
            var suggestedUrls = new List<string>();
            var suggestedBaseEntityMethodUrls = new List<string>();
            if (method.Parameters.Count == 0) {
                suggestedUrls.Add(method.RouteTemplates[0]);
            } else if (method.Parameters.All(p => p.Key.A.SampleValues != null && p.Key.A.SampleValues.Length > 0)) {
                /// We have sample values for all parameters. Permutate between them
                /// TODO: Make better code than this!
                var t = method.RouteTemplates[0];
                if (method.Parameters.Count <= 0) {
                    suggestedUrls.Add(t);
                } else {
                    var p = method.Parameters[0].Key;
                    p.A.SampleValues.ForEach(v0 => {
                        /// TODO: Make better code than this!
                        var t0 = t.Replace("{" + p.PToString + "}", v0);
                        var tBaseEntityMethod0 = p.CoreP != CoreP.QueryId ? null : t; // Keep {QueryId} in this URL
                        if (method.Parameters.Count <= 1) {
                            suggestedUrls.Add(t0);
                            if (tBaseEntityMethod0 != null) suggestedBaseEntityMethodUrls.Add(tBaseEntityMethod0);
                        } else {
                            p = method.Parameters[1].Key;
                            p.A.SampleValues.ForEach(v1 => {
                                /// TODO: Make better code than this!
                                var t1 = t0.Replace("{" + p.PToString + "}", v1);
                                var tBaseEntityMethod1 = tBaseEntityMethod0?.Replace("{" + p.PToString + "}", v1) ?? null;
                                if (method.Parameters.Count <= 2) {
                                    suggestedUrls.Add(t1);
                                    if (tBaseEntityMethod1 != null) suggestedBaseEntityMethodUrls.Add(tBaseEntityMethod1);
                                } else {
                                    p = method.Parameters[2].Key;
                                    p.A.SampleValues.ForEach(v2 => {
                                        /// TODO: Make better code than this!
                                        var t2 = t1.Replace("{" + p.PToString + "}", v2);
                                        var tBaseEntityMethod2 = tBaseEntityMethod1?.Replace("{" + p.PToString + "}", v2) ?? null;
                                        if (method.Parameters.Count <= 3) {
                                            suggestedUrls.Add(t2);
                                            if (tBaseEntityMethod2 != null) suggestedBaseEntityMethodUrls.Add(tBaseEntityMethod2);
                                        } else {
                                            // Add more permutations. 
                                            // TODO: Make better code than this!
                                            throw new NotImplementedException(nameof(method.Parameters) + ".Count >= 3");
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            }

            updater(CoreP.SuggestedUrl.A(), suggestedUrls.Select(s => new Uri(Util.Configuration.C.BaseUrl.ToString() + s)).ToList());

            // TODO: Fix reason for duplicates occurring here (necessitating the Distinct-operation)
            suggestedBaseEntityMethodUrls = suggestedBaseEntityMethodUrls.Distinct().ToList();
            updater(APIMethodP.BaseEntityMethodUrl.A(), suggestedBaseEntityMethodUrls.Select(s => new Uri(Util.Configuration.C.BaseUrl.ToString() + s)).ToList());

            if (method.MA.Environment < Util.Configuration.C.Environment) {
                IgnoredMethods.Add(method); // Moved from start. We want to update database anyway.
            } else {
                _allMethods.Add(method);
            }
        }

        /// <summary>
        /// Consider removing <paramref name="request"/> from <see cref="BaseEntity.ToHTMLTableRowHeading"/>
        /// </summary>
        /// <param name="request"></param>
        /// <returns></returns>
        public override string ToHTMLTableRowHeading(Request request) => HTMLTableHeading;
        public const string HTMLTableHeading = "<tr><th>" + nameof(IdFriendly) + "</th><th>" + nameof(CoreAPIMethod) + "</th><th>" + nameof(CoreP.EntityType) + "</th><th>" + nameof(CoreP.AccessLevelUse) + "</th><th>" + nameof(CoreP.Description) + "</th></tr>";

        public override string ToHTMLTableRow(Request request) => "<tr><td>" +
            (Id <= 0 ? IdFriendly.HTMLEncode() : request.API.CreateAPILink(this)) + "</td><td>" +
            PV(APIMethodP.CoreAPIMethod.A(), Property.HTML.Default) + "</td><td>" +
            PV(CoreP.EntityType.A(), Property.HTML.Default) + "</td><td>" +
            PV(CoreP.AccessLevelUse.A(), Property.HTML.Default) + "</td><td>" + // TODO: Should always be present. Try to do without default value. BUT, will throw exception at first initializatio of a fresh database as of Sep 2017
            PV(CoreP.Description.A(), Property.HTML.Default) + "</td></tr>\r\n";

        public class MethodAttributeInitialisationException : ApplicationException {
            public MethodAttributeInitialisationException(string message) : base(message) { }
        }

        public class MethodNotFoundException : ApplicationException {
            public MethodNotFoundException(CoreAPIMethod coreMethod, Type entityType, string details = null) : this(nameof(coreMethod) + ": " + coreMethod + ", " + nameof(entityType) + ": " + entityType.ToStringShort() + "." + (details == null ? "" : ("\r\nDetails: " + details))) { }
            public MethodNotFoundException(string message) : base(message) { }
        }

        public class InvalidControllernameException : ApplicationException {
            public InvalidControllernameException(string message) : base(message) { }
        }

        protected override void ConnectWithDatabase(BaseDatabase db) => Get(A, db, enrichAndReturnThisObject: this);
    }

    [EnumAttribute(AgoRapideEnumType = EnumType.PropertyKey)]
    public enum APIMethodP {
        None,

        [PropertyKey(Type = typeof(APIMethodOrigin), AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        APIMethodOrigin,

        /// <summary>
        /// See <see cref="APIMethodAttribute.CoreMethod"/>. 
        /// 
        /// Note how we DO NOT set any <see cref="PropertyKeyAttribute.Description"/> description here, but instead rely
        /// on the <see cref="PropertyKeyAttribute.Description"/> set for <see cref="AgoRapide.CoreAPIMethod"/>. 
        /// This comment describes the recommended approach to setting attributes when the type given (<see cref="PropertyKeyAttribute.Type"/>) 
        /// is one of your own classes / enums, or one of the AgoRapide classes / enums 
        /// </summary>
        [PropertyKey(Type = typeof(CoreAPIMethod), PriorityOrder = PriorityOrder.Important, AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        CoreAPIMethod,

        /// <summary>
        /// Note that included values are not limited to <see cref="CoreAPIMethod.BaseEntityMethod"/>.
        /// TODO: Maybe therefore change name of this property?
        /// </summary>
        [PropertyKey(
            Description =
                "Equivalent to -" + nameof(CoreP.SuggestedUrl) + "- with a -" + nameof(QueryId) + "- parameter " +
                "except that the parameter {queryId} is left as a literal string within the string",
            IsMany = true,
            Type = typeof(Uri), AccessLevelRead = AccessLevel.Anonymous, PriorityOrder = PriorityOrder.Important, Parents = new Type[] { typeof(APIMethod) })]
        BaseEntityMethodUrl,

        /// <summary>
        /// Does not originate from <see cref="APIMethodAttribute.RouteTemplate"/> but from
        /// <see cref="APIMethod.RouteTemplates"/>[0]
        /// TODO: Document better!
        /// </summary>
        [PropertyKey(Type = typeof(string), AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        RouteTemplate,

        [PropertyKey(Type = typeof(HTTPMethod), IsMany = true, AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        HTTPMethods,

        /// <summary>
        /// Corresponds to presence of <see cref="System.Web.Http.AuthorizeAttribute"/> or similar 
        /// (like AgoRapideSample.BasicAuthenticationAttribute)
        /// on the <see cref="BaseController"/>-method.
        /// </summary>
        [PropertyKey(
            Description = "Value TRUE signifies that API client needs to supply credentials in order to query API method.",
            Type = typeof(bool), AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        RequiresAuthorization,

        [PropertyKey(
            Description =
                "The Controller class + the method within that class which implements a given method.",
            LongDescription =
                "Has little use except at application startup since " + nameof(ImplementatorId) + " is what automatically connects (enables traversing) to the relevant " + nameof(ClassMember),
            HasLimitedRange = true,
            AccessLevelRead = AccessLevel.Anonymous,
            Type = typeof(string),
            Parents = new Type[] { typeof(APIMethod) })]
        ImplementatorIdFriendly,

        [PropertyKey(
            ForeignKeyOf = typeof(ClassMember),
            HasLimitedRange = true,
            AccessLevelRead = AccessLevel.Anonymous,
            Parents = new Type[] { typeof(APIMethod) })]
        ImplementatorId,

        /// <summary>
        /// See <see cref="APIMethodAttribute.ShowDetailedResult"/>
        /// </summary>
        [PropertyKey(Type = typeof(bool), AccessLevelRead = AccessLevel.Anonymous, Parents = new Type[] { typeof(APIMethod) })]
        ShowDetailedResult,
    }

    public static class APIMethodPExtensions {
        public static PropertyKey A(this APIMethodP p) => PropertyKeyMapper.GetA(p);
    }
}