using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using AgoRapide.Core;
using AgoRapide.Database;
using AgoRapide;
using System.Web.Http;
using System.Reflection;

namespace AgoRapide.API {
    public abstract class BaseController : ApiController {

        protected abstract IDatabase DB { get; }
        public event Action<string> LogEvent;
        protected void Log(string text, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => LogEvent?.Invoke(GetType().ToStringShort() + "." + caller + ": " + text);
        /// <summary>
        /// Logs both via standard <see cref="LogEvent"/> and to <paramref name="result"/> (which will be returned to API-client)
        /// </summary>
        /// <param name="text"></param>
        /// <param name="result"></param>
        /// <param name="caller"></param>
        protected void Log(string text, Result result, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            LogEvent?.Invoke(GetType().ToStringShort() + "." + caller + ": " + text);
            result.LogInternal(text, GetType(), caller);
        }

        /// <summary>
        /// The <see cref="HandledExceptionEvent"/> is used for already handled exceptions in the sense that
        /// what is left for the event handler to do is to log the exception as needed. 
        /// </summary>
        public event Action<Exception> HandledExceptionEvent;

        /// <summary>
        /// Handles API calls (queries) towards the following methods:
        /// 1) All <see cref="APIMethodOrigin.Autogenerated"/>-methods. 
        /// 2) All <see cref="APIMethodOrigin.SemiAutogenerated"/>-methods with missing parameters. 
        ///    (note that even if they do not have <see cref="APIMethod.RequiresAuthorization"/> the client
        ///    still has to supply authorize in order to get help from this method (<see cref="AgoRapideGenericMethod"/>).
        /// 3) General query error handler for API calls not recognized at all. 
        /// 
        /// Note that theoretically this method has the potential power to replace completely the routing mechanism of ASP .NET.
        /// We do however believe that the traditional routing mechanism is best for more distinctive API methods with special functionality. 
        /// So what this method (<see cref="AgoRapideGenericMethod"/>) essentially does is to remove a lot of boilerplate code in your controllers.
        /// </summary>
        /// <param name="method">
        /// This will normally be obtained by the caller from <see cref="GetMethod"/>, that is, it will be the callers 
        /// equivalent of a generic method (which is to be handled here), 
        /// and will again be supposed to have <see cref="APIMethod.RequiresAuthorization"/> 
        /// (that is, <paramref name="currentUser"/> will also be expected to be set)
        /// If called from <see cref="TryGetRequest"/> (when request is attempted HTML-format request misunderstood as JSON request with last parameter like /HTML)
        /// then <<paramref name="method"/> will be that of this method's caller again (that is, any method).
        /// </param>
        /// <param name="currentUser">
        /// Normally set. May be null if <paramref name="method"/> does not have <see cref="APIMethod.RequiresAuthorization"/>. 
        /// See comment for <paramref name="method"/>. 
        /// </param>
        /// <returns></returns>
        public object AgoRapideGenericMethod(APIMethod method, BaseEntity currentUser) {
            // Practical problem: For overloads for which there are allowed default values for
            // parameters we must be able to call the full version. That will be difficult to do 
            // from here. In other words, for the time being (Jan 2017) all such overloads
            // have to be manually implemented as ordinary Controller-methods anyway.
            /// (but <see cref="PropertyKeyAttributeEnriched.TryValidateAndParse"/> will work anyway)

            var url = Request.RequestUri.ToString();
            Log("url: " + url);

            var request = new Request(Request, method, currentUser, exceptionHasOccurred: false);
            var tip = request.ResponseFormat == ResponseFormat.HTML ? "\r\nTip: Add " + Util.Configuration.C.HTMLPostfixIndicator + " at the end of your request URL if you want this response in HTML-format instead of JSON" : "";

            if (!string.IsNullOrEmpty(Util.Configuration.C.APIPrefix) && Util.Configuration.C.APIPrefix.Length > 1) { // In principle length is guaranteed to be more than one when not empty
                var prefix = Util.Configuration.C.ApiPrefixToLower;
                if (!url.ToLower().Contains(prefix)) {
                    var suggestedUrl = Util.Configuration.C.RootUrl + Util.Configuration.C.APIPrefix;
                    request.Result.ResultCode = ResultCode.client_error;
                    request.Result.AddProperty(CoreP.Message.A(), "Did you remember '" + Util.Configuration.C.APIPrefix + "' in your URL?" + tip);
                    request.Result.AddProperty(CoreP.SuggestedUrl.A(), suggestedUrl);
                    return request.GetResponse();
                }
            }

            API.Request.GetMethodsMatchingRequest(Request, request.ResponseFormat, out var exactMatch, out var candidateMatches, out var maybeIntended);

            if (exactMatch != null) {
                var e = exactMatch.Value;
                if (exactMatch.Value.method.Origin != APIMethodOrigin.Autogenerated) throw new Request.MethodMatchingException("Found " + nameof(exactMatch) + " for " + e.method.IdFriendly + " with " + nameof(e.method.Origin) + " " + e.method.Origin + ". These methods are supposed to be handled by the 'ordinary' API .NET routing mechanism.");
                switch (e.method.MA.CoreMethod) {
                    // TODO: Add some automatic extraction of parameters based on knowledge about methods.
                    case CoreAPIMethod.Configuration:
                        return HandleCoreMethodConfiguration(e.method);
                    case CoreAPIMethod.AddEntity: /// Number of parameters will vary (because they are derived from all <see cref="PropertyKeyAttribute.IsObligatory"/> for the actual entity type)
                        if (e.method.Parameters.Count > 5) throw new InvalidCountException("Maximum of 5 " + method.EntityType.ToStringShort() + " -" + nameof(PropertyKeyAttribute.IsObligatory) + "- allowed for " + e.method.MA.CoreMethod + ". Resolution: Limit is arbitrarily set, may easily be increased in C# code.\r\nDetails: " + method.ToString());
                        return HandleCoreMethodAddEntity(e.method,
                            e.method.Parameters.Count <= 0 ? null : e.parameters.GetValue(0, () => method.ToString()),
                            e.method.Parameters.Count <= 1 ? null : e.parameters.GetValue(1, () => method.ToString()),
                            e.method.Parameters.Count <= 2 ? null : e.parameters.GetValue(2, () => method.ToString()),
                            e.method.Parameters.Count <= 3 ? null : e.parameters.GetValue(3, () => method.ToString()),
                            e.method.Parameters.Count <= 4 ? null : e.parameters.GetValue(4, () => method.ToString())
                        // TODO: INCREASE LIMIT OF NUMBER OF PARAMETERS HERE!
                        );
                    // TODO: Add some automatic extraction of parameters based on knowledge about methods.
                    case CoreAPIMethod.EntityIndex: return HandleCoreMethodEntityIndex(e.method, e.parameters.GetValue(0, () => method.ToString()));
                    // TODO: Add some automatic extraction of parameters based on knowledge about methods.
                    // TODO: This one picks 1, 3 and 4 without any explicit information about WHY
                    // TODO: With knowledge of routeTemplate
                    // TODO:   Person/{QueryId}/AddProperty/{Key}/{Value}
                    // TODO: it is possible to automatically find indexes for extraction
                    case CoreAPIMethod.UpdateProperty: return HandleCoreMethodUpdateProperty(e.method, e.parameters.GetValue(0, () => method.ToString()), e.parameters.GetValue(1, () => method.ToString()), e.parameters.GetValue(2, () => method.ToString()));
                    // TODO: Add some automatic extraction of parameters based on knowledge about methods.
                    case CoreAPIMethod.PropertyOperation: return HandleCoreMethodPropertyOperation(e.method, e.parameters.GetValue(0, () => method.ToString()), e.parameters.GetValue(1, () => method.ToString()));
                    // TODO: Add some automatic extraction of parameters based on knowledge about methods.
                    case CoreAPIMethod.History: return HandleCoreMethodHistory(e.method, e.parameters.GetValue(0, () => method.ToString()));
                    default: throw new NotImplementedException(nameof(exactMatch) + " with " + nameof(e.method.MA.CoreMethod) + " " + e.method.MA.CoreMethod);
                }
            } else if (candidateMatches != null) {
                var c = candidateMatches.Value;
                switch (c.methods.Count) {
                    case 0: throw new InvalidCountException(nameof(candidateMatches) + ".Count: " + c.methods.Count);
                    case 1: {
                            var retval = new APIMethodCandidate(request, c.methods[0], c.lastMatchingSegmentNo);
                            request.Result.ResultCode = ResultCode.missing_parameter_error;
                            request.Result.SingleEntityResult = retval;
                            var s = retval.FirstNonMatchingSegment;
                            request.Result.AddProperty(CoreP.Message.A(),
                                "It looks like you tried to access method\r\n" + c.methods[0].ToString() + "\r\n" +
                                (s.Parameter == null ?
                                    "but " + s.SegmentName + " is missing from your URL.\r\n" :
                                    "but parameter {" + s.Parameter.Key.PToString + "} is missing from your URL\r\n") +
                                (string.IsNullOrEmpty(s.SampleValues[0]) ?
                                    ("Unable to suggest a value for you for this missing parameter" + ((s.Parameter?.Key.A.IsPassword ?? false) ? " since it is a password (you must come up with a value by yourself)" : "")) :
                                    "Try to add '" + s.SampleValues[0] + "' to your URL") +
                                tip);
                            request.Result.AddProperty(CoreP.SuggestedUrl.A(), retval.PV<string>(CoreP.SuggestedUrl.A()));
                            return request.GetResponse();
                        }
                    default: {
                            // TODO: Order list by frequency of use and pick the most used methods
                            var retval = c.methods.Select(m => new APIMethodCandidate(request, m, c.lastMatchingSegmentNo)).Take(10).ToList();
                            request.Result.ResultCode = ResultCode.missing_parameter_error;
                            request.Result.MultipleEntitiesResult = retval.Select(r => (BaseEntity)r).ToList();
                            request.Result.AddProperty(CoreP.Message.A(),
                                "Your query URL is incomplete.\r\n" +
                                "Details:\r\n" + c.explanation + "\r\n" +
                                "-----------\r\n" +
                                "Did you try to call one of the following methods:\r\n" +
                                string.Join("\r\n", retval.Select(candidate => candidate.Method.ToString())) + "\r\n?" +
                                "-----------\r\n" +
                                tip);
                            request.Result.AddProperty(CoreP.SuggestedUrl.A(), string.Join("\r\n", retval.Select(candidate => candidate.SuggestedUrl)));
                            return request.GetResponse();
                        }
                }
            } else if (maybeIntended != null) {
                var m = maybeIntended.Value;
                if (m.methods.Count == 0) throw new InvalidCountException(nameof(maybeIntended) + ".Count: " + m.methods.Count);
                request.Result.ResultCode = ResultCode.client_error;
                request.Result.AddProperty(CoreP.Message.A(),
                    "Your query URL was not understood at all.\r\n" +
                    "Details:\r\n" + m.explanation + "\r\n" +
                    "-----------\r\n" +
                    "Did you try to call one of the following methods:\r\n" +
                    string.Join("\r\n", m.methods.Select(c => c.ToString())) + "\r\n?" +
                    "-----------\r\n" +
                    "See enclosed " + nameof(CoreP.SuggestedUrl) + " for documentation" + tip);
                request.Result.MultipleEntitiesResult = m.methods.Select(maybe => (BaseEntity)maybe).ToList();

                /// Generate <see cref="CoreP.SuggestedUrl"/>:
                // var docUrl = request.CreateAPIUrl("") does not work (will give us /api//HTML for example)
                // Therefore we must create the URL manually now:
                var docUrl = Util.Configuration.C.RootUrl + (request.ResponseFormat == ResponseFormat.HTML ? Util.Configuration.C.HTMLPostfixIndicatorWithoutLeadingSlash : "");
                request.Result.AddProperty(CoreP.SuggestedUrl.A(), docUrl);
                request.Result.AddProperty(CoreP.APIDocumentationUrl.A(), docUrl);
                return request.GetResponse();
            } else {
                throw new NullReferenceException("None of " + nameof(exactMatch) + ", " + nameof(candidateMatches) + " or " + nameof(maybeIntended) + " was set");
            }
        }

        public object HandleCoreMethodConfiguration(APIMethod method) {
            Log("");
            method.MA.AssertCoreMethod(CoreAPIMethod.Configuration);
            if (!TryGetRequest(method, out var request, out var completeErrorResponse)) return completeErrorResponse;
            return request.GetOKResponseAsSingleEntity(Util.Configuration);
        }

        public object HandleCoreMethodAddEntity(APIMethod method, string p1, string p2, string p3, string p4, string p5) {
            // TODO: INCREASE LIMIT OF NUMBER OF PARAMETERS HERE!
            Log(nameof(method.EntityType) + ": " + method.EntityType.ToStringShort() + ", " + nameof(p1) + ": " + p1 + ", " + nameof(p2) + ": " + p2 + ", " + nameof(p3) + ": " + p3 + ", " + nameof(p4) + ": " + p4 + ", " + nameof(p5) + ": " + p5);
            method.MA.AssertCoreMethod(CoreAPIMethod.AddEntity);
            if (!TryGetRequest(p1, p2, p3, p4, p5, method, out var request, out var completeErrorResponse)) return completeErrorResponse;
            foreach (var p in request.Parameters.Properties.Values.Where(p => p.Key.Key.A.IsUniqueInDatabase)) {
                if (!DB.TryAssertUniqueness(p.Key, p.Value, out var existing, out var strErrorResponse)) return request.GetErrorResponse(ResultCode.data_error, strErrorResponse);
            }
            return request.GetOKResponseAsEntityId(method.EntityType, DB.CreateEntity(request.CurrentUser.Id, method.EntityType, request.Parameters, request.Result));
        }

        /// <summary>
        /// TODO: For <see cref="APIMethod"/> THERE IS NO NEED OF READING FROM DATABASE!
        /// TODO: All these methods exists in memory anyway (see <see cref="APIMethod.AllMethods"/>)
        /// TODO: (and the in-memory object is "richer")
        /// </summary>
        /// <param name="t"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        public object HandleCoreMethodEntityIndex(APIMethod method, string id) {
            Log(nameof(method.EntityType) + ": " + method.EntityType.ToStringShort() + ", " + nameof(id) + ": " + id);
            method.MA.AssertCoreMethod(CoreAPIMethod.EntityIndex);
            if (!TryGetRequest(id, method, out var request, out var completeErrorResponse)) return completeErrorResponse;
            var queryId = request.Parameters.PVM<QueryId>();

            /// TODO: Mark all <see cref="ClassAttribute"/> with bool UseCache and 
            /// TODO: always read from cache for corresponding <see cref="APIMethod.EntityType"/>
            if (typeof(ApplicationPart).IsAssignableFrom(method.EntityType)) { // Fetch from cache if possible
                if (queryId.IsAll) {
                    return request.GetOKResponseAsMultipleEntities(ApplicationPart.AllApplicationParts.Values.Where(
                        p => method.EntityType.IsAssignableFrom(p.GetType())).Select(a => (BaseEntity)a).ToList());
                } else {
                    switch (queryId) {
                        case QueryIdString q:
                            /// Improve on use of <see cref="QueryId.ToString"/>
                            if (ApplicationPart.AllApplicationParts.TryGetValue(q.ToString(), out var retval) && method.EntityType.IsAssignableFrom(retval.GetType())) {
                                return request.GetOKResponseAsSingleEntity(retval);
                            } break;
                    }
                }
            }

            /// TODO: Utilize <see cref="APIMethod.EntityType"/> here. Maybe give up having TryGetEntities generic?
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Read, useCache: false, requiredType: method.EntityType, entities: out var entities, errorResponse: out var objErrorResponse)) return request.GetErrorResponse(objErrorResponse);
            return request.GetOKResponseAsSingleEntityOrMultipleEntities(queryId, entities);
        }

        public object HandleCoreMethodUpdateProperty(APIMethod method, string id, string key, string value) {
            Log(nameof(id) + ": " + id + ", " + nameof(key) + ": " + key + ", " + nameof(value) + ": " + value);
            method.MA.AssertCoreMethod(CoreAPIMethod.UpdateProperty);
            if (!TryGetRequest(id, key, value, method, out var request, out var completeErrorResponse)) return completeErrorResponse;
            var queryId = request.Parameters.PVM<QueryId>();
            var propertyKeyNonStrict = request.Parameters.PVM<PropertyKey>();
            var strValue = request.Parameters.PV<string>(CoreP.Value.A());
            /// Validate value. Note how TryGetRequest was only able to validate value as string 
            /// because <see cref="CoreAPIMethod.UpdateProperty"/> does not know anything about which values are valid for which keys.
            /// TODO: CONSIDER MAKING THIS EVEN SMARTER!
            if (!propertyKeyNonStrict.Key.TryValidateAndParse(strValue, out var parseResult)) return request.GetErrorResponse(ResultCode.invalid_parameter_error, parseResult.ErrorResponse);
            var objValue = parseResult.Result.Value;

            if (propertyKeyNonStrict.Key.A.IsUniqueInDatabase) {
                /// TODO: Improve on error message here if call to <see cref="PropertyKey.PropertyKeyWithIndex"/> fails.
                if (!DB.TryAssertUniqueness(propertyKeyNonStrict.PropertyKeyWithIndex, objValue, out var existing, out var strErrorResponse)) return request.GetErrorResponse(ResultCode.data_error, strErrorResponse);
                /// Note that <see cref="IDatabase.CreateProperty"/> will also repeat the check above
            }
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Write, useCache: false, requiredType: method.EntityType, entities: out var entities, errorResponse: out var objErrorResponse)) return request.GetErrorResponse(objErrorResponse);
            entities.ForEach(e => DB.UpdateProperty(request.CurrentUser.Id, e, propertyKeyNonStrict, objValue, request.Result));
            request.Result.ResultCode = ResultCode.ok;
            switch (queryId) {
                case QueryIdInteger queryIdInteger: request.Result.AddProperty(CoreP.SuggestedUrl.A(), request.API.CreateAPIUrl(method.EntityType, queryIdInteger.Id)); break;
            }
            request.Result.AddProperty(CoreP.Message.A(), nameof(entities) + ".Count: " + entities.Count);
            return request.GetResponse();
        }

        public object HandleCoreMethodPropertyOperation(APIMethod method, string id, string operation) {
            Log(nameof(id) + ": " + id + ", " + nameof(operation) + ": " + operation);
            method.MA.AssertCoreMethod(CoreAPIMethod.PropertyOperation);
            if (!TryGetRequest(id, operation, method, out var request, out var objErrorResponse)) return objErrorResponse;
            var queryId = request.Parameters.PVM<QueryId>();
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Write, useCache: false, entities: out List<Property> properties, errorResponse: out var tplErrorResponse)) return request.GetErrorResponse(tplErrorResponse);
            properties.ForEach(e => DB.OperateOnProperty(request.CurrentUser.Id, e, request.Parameters.PVM<PropertyOperation>(), request.Result));
            request.Result.ResultCode = ResultCode.ok;
            switch (queryId) {
                case QueryIdInteger integerQueryId: request.Result.AddProperty(CoreP.SuggestedUrl.A(), request.API.CreateAPIUrl(method.EntityType, integerQueryId.Id)); break;
            }
            request.Result.AddProperty(CoreP.Message.A(), nameof(properties) + ".Count: " + properties.Count);
            return request.GetResponse();
        }

        public object HandleCoreMethodHistory(APIMethod method, string id) {
            Log(nameof(id) + ": " + id);
            method.MA.AssertCoreMethod(CoreAPIMethod.History);
            if (!TryGetRequest(id, method, out var request, out var objErrorResponse)) return objErrorResponse;
            if (!DB.TryGetEntity(request.CurrentUser, request.Parameters.PVM<QueryIdInteger>(), AccessType.Read, useCache: false, entity: out BaseEntity entity, errorResponse: out var tplErrorResponse)) return request.GetErrorResponse(tplErrorResponse);
            return request.GetOKResponseAsMultipleEntities(DB.GetEntityHistory(entity).Select(p => (BaseEntity)p).ToList());
        }

        public object HandleCoreMethodExceptionDetails(APIMethod method) {
            Log("");
            method.MA.AssertCoreMethod(CoreAPIMethod.ExceptionDetails);
            var request = new Request(Request, method, CurrentUser(method), exceptionHasOccurred: false);

            var logDirectory = System.IO.Path.GetDirectoryName(Util.Configuration.C.LogPath);
            string newestFilePath = null; var newestTimeStamp = DateTime.MinValue;
            var filePaths = System.IO.Directory.GetFiles(logDirectory, "*exception*");
            foreach (var path in filePaths) {
                var timestamp = System.IO.File.GetCreationTime(path);
                if (timestamp > newestTimeStamp) {
                    newestTimeStamp = timestamp;
                    newestFilePath = path;
                }
            }
            if (newestFilePath == null) return request.GetErrorResponse(ResultCode.data_error, "No Exception found in folder " + logDirectory, "");
            return request.GetOKResponseAsText(
                System.IO.File.ReadAllText(newestFilePath),
                message: "Exception found, dated " + newestTimeStamp.ToString(DateTimeFormat.DateHourMinSecMs) +
                    (filePaths.Length < 100 ? "" : ". " +
                    "WARNING: There is a high number of Exception-files (" + filePaths.Length + ") in folder " + logDirectory + ". " +
                    "Old files should be deleted!")
                );
        }

        /// <summary>
        /// Gets the API method beeing called. Can only be used from within a class and method corresponding to an already
        /// indexed <see cref="APIMethod"/>'s <see cref="APIMethod.Controller"/> and 
        /// <see cref="APIMethod.ControllerMethod"/>
        /// </summary>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected APIMethod GetMethod([System.Runtime.CompilerServices.CallerMemberName] string caller = "") => APIMethod.GetByControllerAndMethodName(GetType(), caller);

        /// <summary>
        /// Made public for documentation purposes.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="errorResponse"></param>
        /// <param name="caller"></param>
        /// <returns></returns>
        public bool TryGetRequest(out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(null, null, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(null, null, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, null, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, null, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, string p5, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, p5, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, string p5, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, p5, null, null, null, null, method, out request, out errorResponse, caller);
        /// <summary>
        /// If succeeds then request will be set. 
        /// If fails then errorResponse will be set, ready for returning to client.
        /// 
        /// Note that using 
        ///   params string[] parameters
        /// might look like a better alternative (resulting in simpler code, less overloads), 
        /// but it would conflict with <paramref name="caller"/> being set "automatically".
        /// </summary>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <param name="p4"></param>
        /// <param name="p5"></param>
        /// <param name="p6"></param>
        /// <param name="p7"></param>
        /// <param name="p8"></param>
        /// <param name="p9"></param>
        /// <param name="method">
        /// Only relevant for <see cref="APIMethodOrigin.Autogenerated"/>. 
        /// If null then will be set by call to <see cref="GetMethod"/>
        /// </param>
        /// <param name="request"></param>
        /// <param name="errorResponse"></param>
        /// <param name="caller">Used to find API method which was called</param>
        /// <returns></returns>
        protected bool TryGetRequest(
            string p1, string p2, string p3, string p4, string p5, string p6, string p7, string p8, string p9,
            APIMethod method,
            out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            if (method == null) method = GetMethod(caller);
            Log(caller + ", " + method.IdFriendly); // +
            /// It is too early to log parameters here because we do not know their names yet. Insted we log AFTER we know the name (see below).
            //    (p1 == null ? "" : ", " + nameof(p1) + ": " + p1) +
            //    (p2 == null ? "" : ", " + nameof(p2) + ": " + p2) +
            //    (p3 == null ? "" : ", " + nameof(p3) + ": " + p3) +
            //    (p4 == null ? "" : ", " + nameof(p4) + ": " + p4) +
            //    (p5 == null ? "" : ", " + nameof(p5) + ": " + p5) +
            //    (p6 == null ? "" : ", " + nameof(p6) + ": " + p6) +
            //    (p7 == null ? "" : ", " + nameof(p7) + ": " + p7) +
            //    (p8 == null ? "" : ", " + nameof(p8) + ": " + p8) +
            //    (p9 == null ? "" : ", " + nameof(p9) + ": " + p9)
            //);
            BaseEntity currentUser = null;
            if (method.RequiresAuthorization) { // TODO: Put functionality for CurrentUser into TryGetRequest instead. ESPECIALLY LETTING TryGetCurrentUser CHECK AccessLevel looks weird
                if (!TryGetCurrentUser(method, out currentUser, out errorResponse)) {
                    request = null;
                    return false;
                }
            }

            { // Check if request is attempted HTML-format request misunderstood as JSON request with last parameter like /HTML
              // This would be due to ASP .NET not being informed of the HTML overload with one less parameter.
              // Call AgoRapideGenericMethod if that is the case. 
                var lastParameter = new Func<string>(() => {
                    if (p9 != null) return p9;
                    if (p8 != null) return p8;
                    if (p7 != null) return p7;
                    if (p6 != null) return p6;
                    if (p5 != null) return p5;
                    if (p4 != null) return p4;
                    if (p3 != null) return p3;
                    if (p2 != null) return p2;
                    if (p1 != null) return p1;
                    return null;
                })();
                if (lastParameter != null && lastParameter.ToLower().Equals(Util.Configuration.C.HTMLPostfixIndicatorWithoutLeadingSlashToLower)) {
                    // This check does not hold. We could check URL direct for /HTML/HTML though...
                    //var tempRequest = new Request(Request, method, currentUser, exceptionHasOccurred: false);
                    //if (tempRequest.ResponseFormat == ResponseFormat.HTML) {
                    //    // Looks like we have something like /HTML/HTML in the URL, in other words, accept the request as is
                    //} else {
                    request = null; // Return as ResultCode.missing_parameter_error response.
                    errorResponse = AgoRapideGenericMethod(method, currentUser);
                    return false;
                    // }
                }
            }
            var parameters = new Dictionary<CoreP, Property>();

            object errorResponseTemp = null;
            var checker = new Func<int, string, bool>((index, parameter) => {
                if (method.Parameters.Count < index) {
                    if (parameter != null) throw new SuperfluousParameterException("Parameter " + index + " (which was given with value '" + parameter + "') is superfluous to " + nameof(method) + " (" + method.IdFriendly + ") which has only " + method.Parameters.Count + " parameters defined");
                    return true;
                }
                //var p = method.Parameters[index - 1].cp; // TODO: Use better names (cp maybe? and a maybe?)
                //var ea = method.Parameters[index - 1].a;
                var par = method.Parameters[index - 1];
                var a = par.Key.A;
                if (parameter == null) parameter = a.DefaultValue;
                if (parameter == null) { // Missing parameter and no default available
                    errorResponseTemp = new Request(Request, method, currentUser, exceptionHasOccurred: false).GetErrorResponse(
                        ResultCode.missing_parameter_error,
                        "Parameter " + index + " (" + par.Key.PToString + ") is missing and there was no " + nameof(PropertyKeyAttribute) + "." + nameof(a.DefaultValue) + " defined.\r\n" +
                        (a.ValidValues != null && a.ValidValues.Length > 0 ? ("\r\n" + nameof(a.ValidValues) + ":\r\n" + string.Join(", ", a.ValidValues)) :
                        (a.SampleValues != null && a.SampleValues.Length > 0 ? ("\r\n" + nameof(a.SampleValues) + ":\r\n" + string.Join(", ", a.SampleValues)) : "")));
                    return false;
                }

                if (!par.Key.TryCleanAndValidateAndParse(parameter, out var parseResult)) {
                    errorResponseTemp = new Request(Request, method, currentUser, exceptionHasOccurred: false).GetErrorResponse(
                        ResultCode.invalid_parameter_error,
                        "Parameter " + index + " (" + par.Key.PToString + ") is invalid.\r\n" +
                        "Details: " + parseResult.ErrorResponse + ". " +
                        (a.ValidValues != null && a.ValidValues.Length > 0 ? ("\r\n" + nameof(a.ValidValues) + ":\r\n" + string.Join(", ", a.ValidValues)) :
                        (a.SampleValues != null && a.SampleValues.Length > 0 ? ("\r\n" + nameof(a.SampleValues) + ":\r\n" + string.Join(", ", a.SampleValues)) : "")));
                    return false;
                }
                parameters.AddValue2(par.Key.CoreP, parseResult.Result);
                Log("Parameter " + par.Key.PToString + ": " + parameter);
                return true;
            });

            request = null;
            if (!checker(1, p1)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(2, p2)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(3, p3)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(4, p4)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(5, p5)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(6, p6)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(7, p7)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(8, p8)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(9, p9)) { errorResponse = errorResponseTemp; return false; }

            errorResponse = null;
            request = new ValidRequest(Request, method, currentUser, new Parameters(parameters));

            return true;
        }

        public class SuperfluousParameterException : ApplicationException {
            public SuperfluousParameterException(string message) : base(message) { }
        }

        /// <summary>
        /// TODO: Put functionality for CurrentUser into TryGetRequest instead
        /// TODO: OR RATHER NOT, we need to access it separately for <see cref="BaseController.AgoRapideGenericMethod"/>
        /// </summary>
        /// <param name="method"></param>
        /// <returns></returns>
        protected BaseEntity CurrentUser(APIMethod method) => TryGetCurrentUser(method, out var currentUser, out _) ? currentUser : throw new UnauthorizedAccessException("Method: " + method.ToString());

        /// <summary>
        /// TODO: Put functionality for CurrentUser into TryGetRequest instead
        /// 
        /// Note that when User.Identity.Name refers to a person with <see cref="CoreP.EntityToRepresent"/> then that entity will be returned 
        /// 
        /// Note how uses Request.Properties["AgoRapideCurrentUser"] if that one exists.
        /// 
        /// Only returns false when <paramref name="currentUser"/>'s <see cref="CoreP.AccessLevelGiven"/> is below the level required. 
        /// In such a case the resulting <see cref="ResultCode.access_error"/> <paramref name="accessDeniedResponse"/> will have a 
        /// <see cref="CoreP.message"/> explaining problem in detail.
        /// 
        /// Throws exception in all other fail cases like invalid long for User.Identity.Name or entity not found in database
        /// </summary>
        /// <param name="currentUser"></param>
        /// <returns></returns>
        protected bool TryGetCurrentUser(APIMethod method, out BaseEntity currentUser, out object accessDeniedResponse) {
            if (string.IsNullOrEmpty(User.Identity.Name)) throw new NoLoginPerformedException(
                "User.Identity.Name was not set.\r\n" +
                "Check that [" + typeof(AuthorizeAttribute) + "] or [OverrideAuthentication] + [BasicAuthentication] or similar has been added as necessary to action-methods in your controller and " +
                "that you are not calling " + MethodBase.GetCurrentMethod().Name + " from a method that does not require authorization");
            if (!long.TryParse(User.Identity.Name, out var entityId)) throw new Exception("Invalid User.Identity.Name (" + User.Identity.Name + ")");
            BaseEntity retval;
            if (Request.Properties.TryGetValue("AgoRapideCurrentUser", out var objCurrentUser)) {
                // The authentication mechanism used has already read the current user for us
                retval = objCurrentUser as BaseEntity;
                if (retval == null) throw new InvalidObjectTypeException(objCurrentUser, typeof(BaseEntity));
                if (retval.Id != entityId) throw new Exception(nameof(retval) + "." + nameof(retval.Id) + " (" + retval.Id + ") != " + nameof(entityId) + " (" + entityId + ")");
            } else {
                retval = DB.GetEntityById<BaseEntity>(entityId);
                DB.SwitchIfHasEntityToRepresent(ref retval);
            }
            if (retval.AccessLevelGiven < method.PV<AccessLevel>(CoreP.AccessLevelUse.A())) {
                accessDeniedResponse = null;
                var request = new Request(Request, method, retval, exceptionHasOccurred: false);
                accessDeniedResponse = request.GetAccessDeniedResponse(nameof(currentUser) + "." + nameof(retval.AccessLevelGiven) + ") (" + retval.AccessLevelGiven + ") is less than method." + nameof(CoreP.AccessLevelUse) + " (" + method.PV<AccessLevel>(CoreP.AccessLevelUse.A()) + ")");
                currentUser = null;
                return false;
            }
            accessDeniedResponse = null;
            currentUser = retval;
            return true;
        }

        //protected abstract string GetHTMLHeading(Request request, string title, ResultCode status);
        //protected abstract string GetHTMLFooter(Request request);

        /// <summary>
        /// Fires <see cref="HandledExceptionEvent"/> and returns information about exception. 
        /// 
        /// The level of information given out to the API client is carefully balanced between 
        /// the conflicting needs of security and usability. For instance we give the 
        /// type of exception but not the message, and we do not give the stack trace,
        /// BUT, we give a link for more details (which usually needs administrative privilegies in order to access)
        /// 
        /// Also note how the code itself is carefully constructed in order to minimize or rather eliminate risk of further exceptions.
        /// </summary>
        /// <param name="ex"></param>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected object HandleExceptionAndGenerateResponse(Exception ex, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            HandledExceptionEvent?.Invoke(ex);
            var exceptionMessage = "";
            Util.ResetEntityCache(); // Reset as a precaution
            var msg = "An internal exception of type " + ex.GetType().ToStringShort() + " occurred in " + GetType().ToStringShort() + ".\r\n" +
                    (string.IsNullOrEmpty(exceptionMessage) ? "" : "Exception message: " + exceptionMessage + ".\r\n") +
                    (string.IsNullOrEmpty(caller) ? "" : "Method that failed: " + caller + ".\r\n") +
                    "Consult log at server for more details.\r\n" +
                    "Cache has been reset as a precaution.\r\n" +
                    "If you have administrative credentials you may try the accompanying exception_details_url";

            // Since Method.GetByControllerAndMethodName may be just the call that failed we have to be very careful here.
            if (!APIMethod.TryGetByControllerAndMethodName(GetType(), caller, out var method)) {
                return JSONView.GenerateEmergencyResult(ResultCode.exception_error,
                    "Method " + GetType() + "." + caller + " not found.\r\n" +
                    "Very unexpected.\r\n" +
                    "Unable to call " + nameof(API.Request) + "." + nameof(API.Request.GetErrorResponse) + " in order to present the following exception information:\r\n" +
                    msg);
            } else { // Preferred variant, calls JSONView.GenerateResult via Request and Result classes.
                return new Request(Request, method, currentUser: null, exceptionHasOccurred: true).GetErrorResponse(ResultCode.exception_error, msg);
            }
        }

        /// <summary>
        /// Returns id of class + method (caller) for use as <see cref="DBField.cid"/> / <see cref="DBField.vid"/> / <see cref="DBField.iid"/> 
        /// (note that usually you should use the "currentUser".id for this purpose)
        /// </summary>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected long GetId(MemberInfo memberInfo) => ApplicationPart.GetClassMember(memberInfo, DB).Id;

        public class NoLoginPerformedException : ApplicationException {
            public NoLoginPerformedException(string message) : base(message) { }
        }
    }
}


