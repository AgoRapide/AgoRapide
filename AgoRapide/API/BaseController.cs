// Copyright (c) 2016, 2017, 2018 Bjørn Erling Fløtten, Trondheim, Norway
// MIT licensed. Details at https://github.com/AgoRapide/AgoRapide/blob/master/LICENSE
using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net;
using AgoRapide.Core;
using AgoRapide.Database;
using AgoRapide;
using System.Web.Http;
using System.Reflection;

namespace AgoRapide.API {

    [Class(Description =
        "Contains functionality for " +
        "parsing and asserting validity of request (like -" + nameof(TryGetRequest) + "-, and " +
        "handling of -" + nameof(CoreAPIMethod) + "- (see -" + nameof(AgoRapideGenericMethod) + "-).")]
    public abstract class BaseController : ApiController {

        protected abstract BaseDatabase DB { get; }
        public event Action<string> LogEvent;
        [ClassMember(Description =
            "-" + nameof(HandledExceptionEvent) + "- is used for already handled exceptions in the sense that " +
            "what is left for the event handler to do is to log the exception as desired."
        )]
        public event Action<Exception> HandledExceptionEvent;

        protected void Log(string text, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => LogEvent?.Invoke(GetType().ToStringShort() + "." + caller + ": " + text);
        /// <summary>
        /// Logs both via standard <see cref="LogEvent"/> and to <paramref name="result"/> (which will be returned to API-client)
        /// </summary>
        /// <param name="text"></param>
        /// <param name="result"></param>
        /// <param name="caller"></param>
        protected void Log(string text, Result result, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            LogEvent?.Invoke(GetType().ToStringShort() + "." + caller + ": " + text);
            if (result == null) throw new NullReferenceException(nameof(result));
            result.LogInternal(text, GetType(), caller);
        }

        /// <summary>
        /// </summary>
        /// <param name="method">
        /// This will normally be obtained by the caller from <see cref="GetMethod"/>, that is, it will be the callers 
        /// equivalent of a generic method (which is to be handled here), 
        /// and will again be supposed to have <see cref="APIMethod.RequiresAuthorization"/> 
        /// (that is, <paramref name="currentUser"/> will also be expected to be set)
        /// If called from <see cref="TryGetRequest"/> (when request is attempted HTML-format request misunderstood as JSON request with last parameter like /HTML)
        /// then <<paramref name="method"/> will be that of this method's caller again (that is, any method).
        /// </param>
        /// <param name="currentUser">
        /// Normally set. May be null if <paramref name="method"/> does not have <see cref="APIMethod.RequiresAuthorization"/>. 
        /// See comment for <paramref name="method"/>. 
        /// </param>
        /// <returns></returns>
        [ClassMember(
            Description =
                "Handles API calls (queries) towards the following methods:\r\n" +
                "1) All -" + nameof(APIMethodOrigin.Autogenerated) + "--methods.\r\n" +
                "2) All -" + nameof(APIMethodOrigin.SemiAutogenerated) + "--methods with missing parameters.\r\n" +
                "   (note that even if they do not have -" + nameof(APIMethod.RequiresAuthorization) + "- the client\r\n" +
                "   still has to supply authorization credentials in order to get help from this method (-" + nameof(AgoRapideGenericMethod) + "-).\r\n" +
                "3) General query error handler for API calls not recognized at all.",
            LongDescription =
                "Note that theoretically this method has the potential power to replace completely the routing mechanism of ASP .NET.\r\n" +
                "We do however believe that the traditional routing mechanism is best for more distinctive API methods with special functionality.\r\n" +
                "So what this method (-" + nameof(AgoRapideGenericMethod) + "-) essentially does is to remove a lot of boilerplate code in your controllers."
        )]
        public object AgoRapideGenericMethod(APIMethod method, BaseEntity currentUser) {
            // Practical problem: For overloads for which there are allowed default values for
            // parameters we must be able to call the full version. That will be difficult to do 
            // from here. In other words, for the time being (Jan 2017) all such overloads
            // have to be manually implemented as ordinary Controller-methods anyway.
            /// (but <see cref="PropertyKeyAttributeEnriched.TryValidateAndParse"/> will work anyway)

            var url = Request.RequestUri.ToString();
            Log("url: " + url);

            var request = new Request(Request, method, currentUser, exceptionHasOccurred: false);
            var tip = request.ResponseFormat == ResponseFormat.HTML ? "\r\nTip: Add " + Util.Configuration.C.HTMLPostfixIndicator + " at the end of your request URL if you want this response in HTML-format instead of JSON" : "";

            if (!string.IsNullOrEmpty(Util.Configuration.C.APIPrefix) && Util.Configuration.C.APIPrefix.Length > 1) { // In principle length is guaranteed to be more than one when not empty
                var prefix = Util.Configuration.C.ApiPrefixToLower;
                if (!url.ToLower().Contains(prefix)) {
                    request.Result.ResultCode = ResultCode.client_error;
                    request.Result.AddProperty(CoreP.Message.A(), "Did you remember '" + Util.Configuration.C.APIPrefix + "' in your URL?" + tip);
                    request.Result.AddProperty(CoreP.SuggestedUrl.A(), Util.Configuration.C.BaseUrl);
                    return request.GetResponse();
                }
            }

            API.Request.GetMethodsMatchingRequest(Request, request.ResponseFormat, out var exactMatch, out var candidateMatches, out var maybeIntended);

            if (exactMatch != null) {
                var e = exactMatch.Value;
                if (e.method.Origin != APIMethodOrigin.Autogenerated) throw new Request.MethodMatchingException("Found " + nameof(exactMatch) + " for " + e.method.IdFriendly + " with " + nameof(e.method.Origin) + " " + e.method.Origin + ". These methods are supposed to be handled by the 'ordinary' API .NET routing mechanism.");

                if (e.method.Parameters.Count > 5) throw new InvalidCountException("Maximum of 5 " + method.EntityType.ToStringShort() + " -" + nameof(PropertyKeyAttribute.IsObligatory) + "- allowed for " + e.method.MA.CoreMethod + ". Resolution: Limit is arbitrarily set, may easily be increased in C# code.\r\nDetails: " + method.ToString());

                if (!TryGetRequest(
                    e.method.Parameters.Count <= 0 ? null : e.parameters.GetValue(0, () => method.ToString()),
                    e.method.Parameters.Count <= 1 ? null : e.parameters.GetValue(1, () => method.ToString()),
                    e.method.Parameters.Count <= 2 ? null : e.parameters.GetValue(2, () => method.ToString()),
                    e.method.Parameters.Count <= 3 ? null : e.parameters.GetValue(3, () => method.ToString()),
                    e.method.Parameters.Count <= 4 ? null : e.parameters.GetValue(4, () => method.ToString()),
                    e.method, out var exactRequest, out var completeErrorResponse)) return completeErrorResponse;

                Log(e.method.MA.CoreMethod + ": " + e.method.EntityType);

                switch (e.method.MA.CoreMethod) {
                    case CoreAPIMethod.BaseEntityMethod: return HandleCoreMethodBaseEntityMethod(exactRequest);
                    case CoreAPIMethod.Configuration: return HandleCoreMethodConfiguration(exactRequest);
                    case CoreAPIMethod.AddEntity: return HandleCoreMethodAddEntity(exactRequest);
                    case CoreAPIMethod.EntityIndex: return HandleCoreMethodEntityIndex(exactRequest);
                    case CoreAPIMethod.UpdateProperty: return HandleCoreMethodUpdateProperty(exactRequest);
                    case CoreAPIMethod.PropertyOperation: return HandleCoreMethodPropertyOperation(exactRequest);
                    case CoreAPIMethod.History: return HandleCoreMethodHistory(exactRequest);
                    case CoreAPIMethod.Context: return HandleCoreMethodContext(exactRequest);
                    default: throw new NotImplementedException(nameof(exactMatch) + " with " + nameof(e.method.MA.CoreMethod) + " " + e.method.MA.CoreMethod);
                }
            } else if (candidateMatches != null) {
                var c = candidateMatches.Value;
                switch (c.methods.Count) {
                    case 0: throw new InvalidCountException(nameof(candidateMatches) + ".Count: " + c.methods.Count);
                    case 1: {
                            var retval = new APIMethodCandidate(request, c.methods[0], c.lastMatchingSegmentNo);
                            request.Result.ResultCode = ResultCode.missing_parameter_error;
                            request.Result.SingleEntityResult = retval;
                            var s = retval.FirstNonMatchingSegment;
                            request.Result.AddProperty(CoreP.Message.A(),
                                "It looks like you tried to access method\r\n" + c.methods[0].ToString() + "\r\n" +
                                (s.Parameter == null ?
                                    "but " + s.SegmentName + " is missing from your URL.\r\n" :
                                    "but parameter {" + s.Parameter.Key.PToString + "} is missing from your URL\r\n") +
                                (string.IsNullOrEmpty(s.SampleValues[0]) ?
                                    ("Unable to suggest a value for you for this missing parameter" + ((s.Parameter?.Key.A.IsPassword ?? false) ? " since it is a password (you must come up with a value by yourself)" : "")) :
                                    "Try to add '" + s.SampleValues[0] + "' to your URL") +
                                tip);
                            request.Result.AddProperty(CoreP.SuggestedUrl.A(), retval.PV<Uri>(CoreP.SuggestedUrl.A()));
                            return request.GetResponse();
                        }
                    default: {
                            // TODO: Order list by frequency of use and pick the most used methods
                            var retval = c.methods.Select(m => new APIMethodCandidate(request, m, c.lastMatchingSegmentNo)).Take(10).ToList();
                            request.Result.ResultCode = ResultCode.missing_parameter_error;
                            request.Result.MultipleEntitiesResult = retval.Select(r => (BaseEntity)r).ToList();
                            request.Result.AddProperty(CoreP.Message.A(),
                                "Your query URL is incomplete.\r\n" +
                                "Details:\r\n" + c.explanation + "\r\n" +
                                "-----------\r\n" +
                                "Did you try to call one of the following methods:\r\n" +
                                string.Join("\r\n", retval.Select(candidate => candidate.Method.ToString())) + "\r\n?" +
                                "-----------\r\n" +
                                tip);
                            request.Result.AddProperty(CoreP.SuggestedUrl.A(), retval.Select(candidate => candidate.PV<Uri>(CoreP.SuggestedUrl.A())).ToList());
                            return request.GetResponse();
                        }
                }
            } else if (maybeIntended != null) {
                var m = maybeIntended.Value;
                if (m.methods.Count == 0) throw new InvalidCountException(nameof(maybeIntended) + ".Count: " + m.methods.Count);
                request.Result.ResultCode = ResultCode.client_error;
                request.Result.AddProperty(CoreP.Message.A(),
                    "Your query URL was not understood at all.\r\n" +
                    "Details:\r\n" + m.explanation + "\r\n" +
                    "-----------\r\n" +
                    "Did you try to call one of the following methods:\r\n" +
                    string.Join("\r\n", m.methods.Select(c => c.ToString())) + "\r\n?" +
                    "-----------\r\n" +
                    "See enclosed " + nameof(CoreP.SuggestedUrl) + " for documentation" + tip);
                request.Result.MultipleEntitiesResult = m.methods.Select(maybe => (BaseEntity)maybe).ToList();

                /// Generate <see cref="CoreP.SuggestedUrl"/>:
                // var docUrl = request.CreateAPIUrl("") does not work (will give us /api//HTML for example)
                // Therefore we must create the URL manually now:
                new Uri(Util.Configuration.C.RootUrl.ToString() + (request.ResponseFormat == ResponseFormat.HTML ? Util.Configuration.C.HTMLPostfixIndicatorWithoutLeadingSlash : "")).Use(u => {
                    request.Result.AddProperty(CoreP.SuggestedUrl.A(), u);
                    request.Result.AddProperty(CoreP.APIDocumentationUrl.A(), u);
                });
                return request.GetResponse();
            } else {
                throw new NullReferenceException("None of " + nameof(exactMatch) + ", " + nameof(candidateMatches) + " or " + nameof(maybeIntended) + " was set");
            }
        }

        /// <summary>
        /// TODO: Use <see cref="APIMethodOrigin.Autogenerated"/>-routing directly to this method. 
        /// </summary>
        /// <typeparam name="TPerson">Must correspond to <see cref="ConfigurationAttribute.TPersonType"/></typeparam>
        /// <param name="request">Parameters must correspond to <see cref="PropertyKeyAttribute.IsObligatory"/> for <typeparamref name="TPerson"/></param>
        /// <returns></returns>
        [ClassMember(Description = "Adds the first administrative user to the system. Only allowed if no entities of given type parameter exists")]
        public object AddFirstAdminUser<TPerson>(ValidRequest request) where TPerson : BaseEntity, new() {
            InvalidTypeException.AssertEquals(typeof(TPerson), Util.Configuration.C.TPersonType, () => 
                "Type given to " + nameof(AddFirstAdminUser) + " must be of type specified by " +
                "configuration attribute " + nameof(ConfigurationAttribute.TPersonType) + " (" + Util.Configuration.C.TPersonType.ToStringShort() + ")");

            /// Check that the only <typeparam name="TPerson"/> entity in the database at the moment is the anonymous user created by Startup.cs
            /// TODO: CHANGE TO CHECK IN <see cref="CoreStartup.Initialize{TPerson}"/> IF TPERSON EXISTS AND DISABLE THIS METHOD IF IT DOES 
            /// TODO: (less costly, less risk of DDOS against this method)
            /// TODO: (it not disabled we can still make a check, reading all entities)
            var persons = DB.GetRootPropertyIds(typeof(TPerson));  // TODO: This is costly! Check in a less costly manner!
                                                                   // TODO: If client has forgot admin credentials, give instructions for recovery. Like sending e-mail, deleting
                                                                   // TODO: password from database or deleting all properties for admin-user.
            if (persons.Count == 0) throw new InvalidCountException("No objects of type " + typeof(TPerson).ToStringShort() + " found in database, not even the anonymous user. The anonymous user should have been created at application startup.");
            var au = Util.Configuration.C.AnonymousUser;
            if (persons.Count > 1) return request.GetErrorResponse(ResultCode.data_error, "An admin user already exists. There is no need for calling this method.");
            if (persons[0] != au.Id) throw new ApplicationException(nameof(Util.Configuration.C.AnonymousUser) + " not set up correctly (" + nameof(au.Id) + " " + au.Id + " does not correspond to " + nameof(DB.GetRootPropertyIds) + " result which was " + persons[0] + ")");
            request.Parameters.AddProperty(CoreP.AccessLevelGiven.A(), AccessLevel.Admin);
            request.Result.LogInternal(
                "Note how this API-method gives you a high level of details in the generated result because " +
                "-" + nameof(APIMethodAttribute) + "." + nameof(APIMethodAttribute.ShowDetailedResult) + "- = true", GetType());
            return request.GetOKResponseAsEntityId(typeof(TPerson), DB.CreateEntity<TPerson>(GetId(MethodBase.GetCurrentMethod()), request.Parameters, request.Result), null);
        }
        /// <summary>
        /// Supporting method for handling <see cref="CoreAPIMethod.GeneralQuery"/>
        /// 
        /// Returns, for each <typeparamref name="TPerson"/>-entity found, a suggestion for setting 
        /// <see cref="CoreP.EntityToRepresent"/> to that entity.
        /// 
        /// Note how 
        /// 1) Search will always be done viewed from <see cref="BaseEntity.RepresentedByEntity"/> if set, 
        /// and correspondingly, 
        /// 2) The returned suggestions are for setting <see cref="CoreP.EntityToRepresent"/> for <see cref="BaseEntity.RepresentedByEntity"/> if set
        /// </summary>
        /// <typeparam name="TPerson">
        /// Must be equal to <see cref="ConfigurationAttribute.TPersonType"/>
        /// </typeparam>
        /// <param name="GeneralQueryId">
        /// The application specific description of how to actually execute the query, for instance 
        /// something like WHERE first_name ILIKE 'something' OR last_name ILIKE 'something'.
        /// </param>
        /// <returns></returns>
        public object GeneralQuery<TPerson>(ValidRequest request, QueryId queryId) where TPerson : BaseEntity, new() {
            InvalidTypeException.AssertEquals(typeof(TPerson), Util.Configuration.C.TPersonType, () => 
                "Type parameter given to " + nameof(GeneralQuery) + " must be of type specified by " +
                "configuration attribute " + nameof(ConfigurationAttribute.TPersonType) + " (" + Util.Configuration.C.TPersonType.ToStringShort() + ")");

            /// Note relatively expensive reading from database of whole <see cref="TPerson"/>-objects now,
            /// while we really only need the actuall identification.
            if (!DB.TryGetEntities(
                request.CurrentUser.RepresentedByEntity ?? request.CurrentUser, /// Note how search will always be done viewed from <see cref="BaseEntity.RepresentedByEntity"/>
                queryId,
                AccessType.Read,
                entities: out List<TPerson> tpersons,
                errorResponse: out var tplErrorResponse)) return request.GetErrorResponse(tplErrorResponse);
            if (tpersons.Count == 0) {
                // It is somewhat dubious to classify this as an error...
                return request.GetErrorResponse(ResultCode.data_error, "No " + typeof(TPerson).ToStringVeryShort() + " found for query '" + queryId + "'");
            }
            /// Return suggestions for setting <see cref="CoreP.EntityToRepresent"/> to one of the actual entities found.
            return request.GetOKResponseAsMultipleEntities(tpersons.Select(p =>
                (BaseEntity)new GeneralQueryResult(
                request.API.CreateAPIUrl(
                    CoreAPIMethod.UpdateProperty,
                    typeof(TPerson),  
                    new QueryIdInteger(
                        request.CurrentUser.RepresentedByEntity?.Id ?? request.CurrentUser.Id /// Note important point here, do NOT set <see cref="CoreP.EntityToRepresent"/> for the entity being represented, but the entity representing.
                    ), CoreP.EntityToRepresent, p.Id.ToString()
                ),
                p.IdFriendly
           )).ToList());
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.BaseEntityMethod) + "-.")]
        public object HandleCoreMethodBaseEntityMethod(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.BaseEntityMethod);
            var queryId = request.Parameters.PV<QueryId>(CoreP.QueryId.A());
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Read, requiredType: request.Method.EntityType, entities: out var entities, errorResponse: out var objErrorResponse)) return request.GetErrorResponse(objErrorResponse);
            switch (entities.Count) {
                case 0:
                    return request.GetErrorResponse(new ErrorResponse(ResultCode.data_error, "No entities found"));
                case 1:
                    try {
                        return request.Method.BaseEntityMethod.Invoke(entities[0], new object[] { DB, request });
                    } catch (Exception ex) {
                        var msg = "Unable to invoke " + entities[0].GetType() + "." + request.Method.BaseEntityMethod.Name + "(" + typeof(BaseDatabase) + ", " + typeof(ValidRequest) + ") for " + entities[0].ToString();
                        if (ex is TargetInvocationException && ex.InnerException != null) {
                            throw new TargetInvocationException(
                                msg + "\r\n" +
                                "Possible cause: Look for InnerException " + ex.InnerException.GetType() + " with message\r\n" +
                                ex.InnerException.Message, ex);
                        } else {
                            throw new MissingMethodException(msg, ex);
                        }
                    }
                default:
                    /// There is noe mechanism for combining the results from multiple methods since they may be any kind of <see cref"object"/>
                    /// Therefore we do not allow multiple entities here
                    return request.GetErrorResponse(new ErrorResponse(ResultCode.data_error, "Multiple entities found (" + entities.Count + ")"));
            }
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.Configuration) + "-.")]
        public object HandleCoreMethodConfiguration(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.Configuration);
            return request.GetOKResponseAsSingleEntity(Util.Configuration);
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.AddEntity) + "-.")]
        public object HandleCoreMethodAddEntity(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.AddEntity);
            /// TODO: Verify that all <see cref="PropertyKeyAttribute.IsObligatory"/> really has been received now
            /// TOOD: (or put that functionality into <see cref="BaseDatabase"/>
            foreach (var p in request.Parameters.Properties.Values.Where(p => p.Key.Key.A.IsUniqueInDatabase)) {
                if (!DB.TryAssertUniqueness(p.Key, p.Value, out var existing, out var strErrorResponse)) return request.GetErrorResponse(ResultCode.data_error, strErrorResponse);
            }
            return request.GetOKResponseAsEntityId(request.Method.EntityType, DB.CreateEntity(request.CurrentUser.Id, request.Method.EntityType, request.Parameters, request.Result));
        }


        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.EntityIndex) + "-.")]
        public object HandleCoreMethodEntityIndex(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.EntityIndex);
            var queryId = request.Parameters.PV<QueryId>(CoreP.QueryId.A());

            /// TODO: Replace code below with automatic use of <see cref="InMemoryCache"/> from <see cref="BaseDatabase"/>
            /// -------------------
            /// TODO: Mark all <see cref="ClassAttribute"/> with bool UseCache and 
            /// TODO: always read from cache for corresponding <see cref="APIMethod.EntityType"/>
            /// TODO: (use <see cref="InMemoryCache"/> for this)
            if (typeof(ApplicationPart).IsAssignableFrom(request.Method.EntityType)) { // Fetch from cache if possible

                //if (queryId.IsAll) {
                //    return request.GetOKResponseAsMultipleEntities(ApplicationPart.AllApplicationParts.Values.Where(
                //        p => request.Method.EntityType.IsAssignableFrom(p.GetType())).Select(a => (BaseEntity)a).ToList());
                //} else {
                switch (queryId) {
                    case QueryIdAll q:
                        return request.GetOKResponseAsMultipleEntities(ApplicationPart.AllApplicationParts.Values.Select(a => (BaseEntity)a).ToList()); ;
                    case QueryIdString q:
                        /// Improve on use of <see cref="QueryId.ToString"/>
                        if (ApplicationPart.AllApplicationParts.TryGetValue(q.ToString(), out var retval) && request.Method.EntityType.IsAssignableFrom(retval.GetType())) {
                            return request.GetOKResponseAsSingleEntity(retval);
                        }
                        break;
                }
                // }
            }

            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Read, requiredType: request.Method.EntityType, entities: out var entities, errorResponse: out var objErrorResponse)) return request.GetErrorResponse(objErrorResponse);
            // HACK: Try to find a better way to initialize this value, and a better place to store this value. 
            if (queryId is QueryIdContext) request.PriorityOrderLimit = PriorityOrder.Neutral; /// Include more data since default is only <see cref="PriorityOrder.Important"/>
            return request.GetOKResponseAsSingleEntityOrMultipleEntities(queryId, entities);
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.UpdateProperty) + "-.")]
        public object HandleCoreMethodUpdateProperty(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.UpdateProperty);
            var queryId = request.Parameters.PV<QueryId>(CoreP.QueryId.A());
            var propertyKeyNonStrict = request.Parameters.PVM<PropertyKey>();
            var strValue = request.Parameters.PV<string>(PropertyP.PropertyValue.A());
            /// Validate value. Note how TryGetRequest was only able to validate value as string 
            /// because <see cref="CoreAPIMethod.UpdateProperty"/> does not know anything about which values are valid for which keys.
            /// TODO: CONSIDER MAKING THIS EVEN SMARTER!
            if (!propertyKeyNonStrict.Key.TryValidateAndParse(strValue, out var parseResult)) return request.GetErrorResponse(ResultCode.invalid_parameter_error, parseResult.ErrorResponse);
            var objValue = parseResult.Result.Value;

            if (propertyKeyNonStrict.Key.A.IsUniqueInDatabase) {
                /// TODO: Improve on error message here if call to <see cref="PropertyKey.PropertyKeyWithIndex"/> fails.
                if (!DB.TryAssertUniqueness(propertyKeyNonStrict.PropertyKeyWithIndex, objValue, out var existing, out var strErrorResponse)) return request.GetErrorResponse(ResultCode.data_error, strErrorResponse);
                /// Note that <see cref="BaseDatabase.CreateProperty"/> will also repeat the check above
            }
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Write, requiredType: request.Method.EntityType, entities: out var entities, errorResponse: out var objErrorResponse)) return request.GetErrorResponse(objErrorResponse);
            entities.ForEach(e => DB.UpdateProperty(request.CurrentUser.Id, e, propertyKeyNonStrict, objValue, request.Result));
            request.Result.ResultCode = ResultCode.ok;
            switch (queryId) {
                case QueryIdInteger queryIdInteger: request.Result.AddProperty(CoreP.SuggestedUrl.A(), request.API.CreateAPIUrl(request.Method.EntityType, queryIdInteger.Id)); break;
            }
            request.Result.AddProperty(CoreP.Message.A(), nameof(entities) + ".Count: " + entities.Count);
            return request.GetResponse();
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.PropertyOperation) + "-.")]
        public object HandleCoreMethodPropertyOperation(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.PropertyOperation);
            var queryId = request.Parameters.PV<QueryId>(CoreP.QueryId.A());
            if (!DB.TryGetEntities(request.CurrentUser, queryId, AccessType.Write, entities: out List<Property> properties, errorResponse: out var tplErrorResponse)) return request.GetErrorResponse(tplErrorResponse);
            properties.ForEach(e => DB.OperateOnProperty(request.CurrentUser.Id, e, request.Parameters.PVM<PropertyOperation>(), request.Result));
            request.Result.ResultCode = ResultCode.ok;
            switch (queryId) { // For single entity, suggest url for verification of operation
                case QueryIdInteger integerQueryId: request.Result.AddProperty(CoreP.SuggestedUrl.A(), request.API.CreateAPIUrl(request.Method.EntityType, integerQueryId.Id)); break;
            }
            request.Result.AddProperty(CoreP.Message.A(), nameof(properties) + ".Count: " + properties.Count);
            return request.GetResponse();
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.History) + "-.")]
        public object HandleCoreMethodHistory(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.History);
            if (!DB.TryGetEntity(request.CurrentUser, request.Parameters.PVM<QueryIdInteger>(), AccessType.Read, entity: out BaseEntity entity, errorResponse: out var tplErrorResponse)) return request.GetErrorResponse(tplErrorResponse);
            return request.GetOKResponseAsMultipleEntities(DB.GetEntityHistory(entity).Select(p => (BaseEntity)p).ToList());
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.Context) + "-.")]
        public object HandleCoreMethodContext(ValidRequest request) {
            request.Method.MA.AssertCoreMethod(CoreAPIMethod.Context);
            var context = request.CurrentUser.PV(CoreP.Context.A(), new List<Context>()); /// TODO: Implement <see cref="BaseEntity.PVM{T}"/> also for lists

            if (context.Count == 0) { 
                /// There is existing context defined for the user, instead of just returning an empty result, 
                /// suggest starting points for setting contexts in the form of querying for all relevant types 
                /// all instances of that type.
                /// (in other words, suggest to start the drill-down process by setting context to something like
                /// Person/All, Order/All, Product/All or similar).
                return request.GetOKResponseAsMultipleEntities(APIMethod.AllBaseEntityDerivedTypes.Select(type => 
                    (BaseEntity)new GeneralQueryResult(
                        request.API.CreateAPIUrl(
                            CoreAPIMethod.UpdateProperty,
                            request.CurrentUser.GetType(),
                            new QueryIdInteger(request.CurrentUser.Id),
                            CoreP.Context.A(),
                            new Context(SetOperator.Intersect, type, new QueryIdAll()).ToString()
                        ),
                        "Set context to " + type.ToStringVeryShort()
                    )
                ).ToList());
            }

            // Show actual (current) context for this user.
            request.Result.MultipleEntitiesResult = new List<BaseEntity>();

            if (!Context.TryExecuteContextsQueries(request.CurrentUser, context, DB, request.Result, out var retval, out var errorResponse)) return request.GetErrorResponse(errorResponse);

            retval.ForEach(type => { /// For each type add links to all entities of this type All entities of this type (also repeated, see below)
                request.Result.MultipleEntitiesResult.Add(new GeneralQueryResult(
                    request.API.CreateAPIUrl(
                        CoreAPIMethod.EntityIndex,
                        type.Key,
                        new QueryIdContext()),
                    type.Key.ToStringVeryShort() + " (" + type.Value.Count + ")"
                ));
            });


            if (request.CurrentUser.Properties.TryGetValue(CoreP.Context, out var contextParent)) { // Suggest removal of context properties
                request.Result.MultipleEntitiesResult.AddRange(contextParent.Properties.Values.Select(p => (BaseEntity)new GeneralQueryResult(
                     request.API.CreateAPIUrl(
                         CoreAPIMethod.PropertyOperation,
                         typeof(Property),
                        new QueryIdInteger(p.Id),
                        PropertyOperation.SetInvalid
                    ),
                    p.V<string>() + " => " + PropertyOperation.SetInvalid
                )));
            }

            retval.ForEach(type => { /// For each type add links to all entities of this type All entities of this type (repeated from above)
                request.Result.MultipleEntitiesResult.Add(new GeneralQueryResult(
                    request.API.CreateAPIUrl(
                        CoreAPIMethod.EntityIndex,
                        type.Key,
                        new QueryIdContext()),
                    type.Key.ToStringVeryShort() + " (" + type.Value.Count + ")"
                ));

                DrillDownSuggestion.Create(type.Key, type.Value.Values, 
                    maxSuggestionsPerKey: 5 // Present some drill-down suggestions. TODO: Find better way of organising this. 
                ).ForEach(coreP => { 
                    /// TODO: Structure of result from <see cref="DrillDownSuggestion.Create"/> is too complicated. 
                    var corePAsString = coreP.Key.A().Key.PToString;
                    coreP.Value.ForEach(_operator => {
                        _operator.Value.ForEach(suggestion => {
                            new List<SetOperator> {
                                SetOperator.Intersect,
                                // Removed Remove and Union 13 Oct 2017. We just got too many suggestions (over 1000), meaning that
                                // not all would be shown in HTML-view for instance.
                                // SetOperator.Remove,
                                // SetOperator.Union /// Note how <see cref="SetOperator.Union"/> is a bit weird. It will only have effect if some context properties are later removed (see suggestions below).
                            }.ForEach(s =>
                               request.Result.MultipleEntitiesResult.Add(suggestion.Value.ToAddToContextUrl(s, request, s == SetOperator.Intersect ? (s + " " + type.Key.ToStringVeryShort() + " " + corePAsString + " " + _operator.Key) : s.ToString(), useOnlyHeader: s != SetOperator.Intersect))
                            );
                        });
                    });
                });
            });

            request.Result.ResultCode = ResultCode.ok;
            return request.GetResponse();
        }

        [ClassMember(Description = "See " + nameof(CoreAPIMethod) + ".-" + nameof(CoreAPIMethod.ExceptionDetails) + "-.")]
        public object HandleCoreMethodExceptionDetails(APIMethod method) {
            Log("");
            method.MA.AssertCoreMethod(CoreAPIMethod.ExceptionDetails);
            var request = new Request(Request, method, GetCurrentUser(method), exceptionHasOccurred: false);

            var logDirectory = System.IO.Path.GetDirectoryName(Util.Configuration.C.LogPath);
            string newestFilePath = null; var newestTimeStamp = DateTime.MinValue;
            var filePaths = System.IO.Directory.GetFiles(logDirectory, "*exception*");
            foreach (var path in filePaths) {
                var timestamp = System.IO.File.GetCreationTime(path);
                if (timestamp > newestTimeStamp) {
                    newestTimeStamp = timestamp;
                    newestFilePath = path;
                }
            }
            if (newestFilePath == null) return request.GetErrorResponse(ResultCode.data_error, "No Exception found in folder " + logDirectory, "");
            return request.GetOKResponseAsText(
                System.IO.File.ReadAllText(newestFilePath),
                message: "Exception found, dated " + newestTimeStamp.ToString(DateTimeFormat.DateHourMinSecMs) +
                    (filePaths.Length < 100 ? "" : ". " +
                    "WARNING: There is a high number of Exception-files (" + filePaths.Length + ") in folder " + logDirectory + ". " +
                    "Old files should be deleted!")
                );
        }

        /// <summary>
        /// Gets the API method beeing called. Can only be used from within a class and method corresponding to an already
        /// indexed <see cref="APIMethod"/>'s <see cref="APIMethod.Controller"/> and 
        /// <see cref="APIMethod.ControllerMethod"/>
        /// </summary>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected APIMethod GetMethod([System.Runtime.CompilerServices.CallerMemberName] string caller = "") => APIMethod.GetByControllerAndMethodName(GetType(), caller);

        /// <summary>
        /// Made public for documentation purposes.
        /// </summary>
        /// <param name="request"></param>
        /// <param name="errorResponse"></param>
        /// <param name="caller"></param>
        /// <returns></returns>
        public bool TryGetRequest(out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(null, null, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(null, null, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, null, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, null, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, null, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, null, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, null, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, null, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, null, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, null, null, null, null, null, method, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, string p5, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, p5, null, null, null, null, null, out request, out errorResponse, caller);
        protected bool TryGetRequest(string p1, string p2, string p3, string p4, string p5, APIMethod method, out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") => TryGetRequest(p1, p2, p3, p4, p5, null, null, null, null, method, out request, out errorResponse, caller);
        /// <summary>
        /// If succeeds then request will be set. 
        /// If fails then errorResponse will be set, ready for returning to client.
        /// 
        /// Note that using 
        ///   params string[] parameters
        /// might look like a better alternative (resulting in simpler code, less overloads), 
        /// but it would conflict with <paramref name="caller"/> being set "automatically".
        /// </summary>
        /// <param name="p1"></param>
        /// <param name="p2"></param>
        /// <param name="p3"></param>
        /// <param name="p4"></param>
        /// <param name="p5"></param>
        /// <param name="p6"></param>
        /// <param name="p7"></param>
        /// <param name="p8"></param>
        /// <param name="p9"></param>
        /// <param name="method">
        /// Only relevant for <see cref="APIMethodOrigin.Autogenerated"/>. 
        /// If null then will be set by call to <see cref="GetMethod"/>
        /// </param>
        /// <param name="request"></param>
        /// <param name="errorResponse"></param>
        /// <param name="caller">Used to find API method which was called</param>
        /// <returns></returns>
        protected bool TryGetRequest(
            string p1, string p2, string p3, string p4, string p5, string p6, string p7, string p8, string p9,
            APIMethod method,
            out ValidRequest request, out object errorResponse, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            if (method == null) method = GetMethod(caller);
            Log(caller + ", " + method.IdFriendly); // It is too early to log parameters here because we do not know their names yet. Insted we log AFTER we know the name (see below).

            BaseEntity currentUser = null;
            if (method.RequiresAuthorization) { // TODO: Put functionality for CurrentUser into TryGetRequest instead. ESPECIALLY LETTING TryGetCurrentUser CHECK AccessLevel looks weird
                if (!TryGetCurrentUser(method, out currentUser, out errorResponse)) {
                    request = null;
                    return false;
                }
            }

            if (!Util.Configuration.C.TryAssertHTTPSAsRelevant(Request.RequestUri, out var strErrorRsponse)) {
                errorResponse = new Request(Request, method, currentUser, exceptionHasOccurred: false).GetErrorResponse(ResultCode.client_error, strErrorRsponse);
                request = null;
                return false;
            }

            { /// Check if request is attempted <see cref="ResponseFormat.HTML"/> / <see cref="ResponseFormat.CSV"/>-request 
              /// misunderstood as <see cref="ResponseFormat.JSON"/>-request with last parameter like /HTML or /CSV
              /// This would be due to ASP .NET not being informed of the HTML / CSV overload with one less parameter.
              /// Call AgoRapideGenericMethod if that is the case. 
                var lastParameter = new Func<string>(() => {
                    if (p9 != null) return p9.ToLower();
                    if (p8 != null) return p8.ToLower();
                    if (p7 != null) return p7.ToLower();
                    if (p6 != null) return p6.ToLower();
                    if (p5 != null) return p5.ToLower();
                    if (p4 != null) return p4.ToLower();
                    if (p3 != null) return p3.ToLower();
                    if (p2 != null) return p2.ToLower();
                    if (p1 != null) return p1.ToLower();
                    return null;
                })();
                if (lastParameter != null && (
                    lastParameter.Equals(Util.Configuration.C.HTMLPostfixIndicatorWithoutLeadingSlashToLower) ||
                    lastParameter.Equals(Util.Configuration.C.CSVPostfixIndicatorWithoutLeadingSlashToLower))) {
                    // This check does not hold. We could check URL direct for /HTML/HTML or /CSV/CSV though...
                    //var tempRequest = new Request(Request, method, currentUser, exceptionHasOccurred: false);
                    //if (tempRequest.ResponseFormat == ResponseFormat.HTML) { (OR CSV)
                    //    // Looks like we have something like /HTML/HTML in the URL, in other words, accept the request as is
                    //} else {
                    request = null; // Return as ResultCode.missing_parameter_error response.
                    errorResponse = AgoRapideGenericMethod(method, currentUser);
                    return false;
                    // }
                }
            }
            var parameters = new ConcurrentDictionary<CoreP, Property>();

            object errorResponseTemp = null;
            var checker = new Func<int, string, bool>((index, parameter) => {
                if (method.Parameters.Count < index) {
                    if (parameter != null) throw new SuperfluousParameterException("Parameter " + index + " (which was given with value '" + parameter + "') is superfluous to " + nameof(method) + " (" + method.IdFriendly + ") which has only " + method.Parameters.Count + " parameters defined");
                    return true;
                }
                //var p = method.Parameters[index - 1].cp; // TODO: Use better names (cp maybe? and a maybe?)
                //var ea = method.Parameters[index - 1].a;
                var par = method.Parameters[index - 1];
                var a = par.Key.A;
                if (parameter == null) parameter = a.DefaultValue;
                if (parameter == null) { // Missing parameter and no default available
                    errorResponseTemp = new Request(Request, method, currentUser, exceptionHasOccurred: false).GetErrorResponse(
                        ResultCode.missing_parameter_error,
                        "Parameter " + index + " (" + par.Key.PToString + ") is missing and there was no " + nameof(PropertyKeyAttribute) + "." + nameof(a.DefaultValue) + " defined.\r\n" +
                        (a.ValidValues != null && a.ValidValues.Length > 0 ? ("\r\n" + nameof(a.ValidValues) + ":\r\n" + string.Join(", ", a.ValidValues)) :
                        (a.SampleValues != null && a.SampleValues.Length > 0 ? ("\r\n" + nameof(a.SampleValues) + ":\r\n" + string.Join(", ", a.SampleValues)) : "")));
                    return false;
                }

                if (!par.Key.TryCleanAndValidateAndParse(parameter, out var parseResult)) {
                    errorResponseTemp = new Request(Request, method, currentUser, exceptionHasOccurred: false).GetErrorResponse(
                        ResultCode.invalid_parameter_error,
                        "Parameter " + index + " (" + par.Key.PToString + ") is invalid.\r\n" +
                        "Details: " + parseResult.ErrorResponse + ". " +
                        (a.ValidValues != null && a.ValidValues.Length > 0 ? ("\r\n" + nameof(a.ValidValues) + ":\r\n" + string.Join(", ", a.ValidValues)) :
                        (a.SampleValues != null && a.SampleValues.Length > 0 ? ("\r\n" + nameof(a.SampleValues) + ":\r\n" + string.Join(", ", a.SampleValues)) : "")));
                    return false;
                }
                parameters.AddValue2(par.Key.CoreP, parseResult.Result);
                Log("Parameter " + par.Key.PToString + ": " + parameter);
                return true;
            });

            request = null;
            if (!checker(1, p1)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(2, p2)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(3, p3)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(4, p4)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(5, p5)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(6, p6)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(7, p7)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(8, p8)) { errorResponse = errorResponseTemp; return false; }
            if (!checker(9, p9)) { errorResponse = errorResponseTemp; return false; }

            errorResponse = null;
            request = new ValidRequest(Request, method, currentUser, new Parameters(parameters));

            return true;
        }

        public class SuperfluousParameterException : ApplicationException {
            public SuperfluousParameterException(string message) : base(message) { }
        }

        /// <summary>
        /// TODO: Put functionality for CurrentUser into TryGetRequest instead
        /// TODO: OR RATHER NOT, we need to access it separately for <see cref="BaseController.AgoRapideGenericMethod"/>
        /// </summary>
        /// <param name="method"></param>
        /// <returns></returns>
        protected BaseEntity GetCurrentUser(APIMethod method) => TryGetCurrentUser(method, out var currentUser, out _) ? currentUser : throw new UnauthorizedAccessException("Method: " + method.ToString());

        /// <summary>
        /// TODO: Put functionality for CurrentUser into TryGetRequest instead
        /// 
        /// Note that when User.Identity.Name refers to a person with <see cref="CoreP.EntityToRepresent"/> then that entity will be returned 
        /// 
        /// Note how uses Request.Properties["AgoRapideCurrentUser"] if that one exists.
        /// 
        /// Only returns false when <paramref name="currentUser"/>'s <see cref="CoreP.AccessLevelGiven"/> is below the level required. 
        /// In such a case the resulting <see cref="ResultCode.access_error"/> <paramref name="accessDeniedResponse"/> will have a 
        /// <see cref="CoreP.message"/> explaining problem in detail.
        /// 
        /// Throws exception in all other fail cases like invalid long for User.Identity.Name or entity not found in database
        /// </summary>
        /// <param name="currentUser"></param>
        /// <returns></returns>
        protected bool TryGetCurrentUser(APIMethod method, out BaseEntity currentUser, out object accessDeniedResponse) {
            if (string.IsNullOrEmpty(User.Identity.Name)) throw new NoLoginPerformedException(
                "User.Identity.Name was not set.\r\n" +
                "Check that [" + typeof(AuthorizeAttribute) + "] or [OverrideAuthentication] + [BasicAuthentication] or similar has been added as necessary to action-methods in your controller and " +
                "that you are not calling " + MethodBase.GetCurrentMethod().Name + " from a method that does not require authorization");
            if (!long.TryParse(User.Identity.Name, out var entityId)) throw new Exception("Invalid User.Identity.Name (" + User.Identity.Name + ")");
            BaseEntity retval;
            if (Request.Properties.TryGetValue("AgoRapideCurrentUser", out var objCurrentUser)) {
                // The authentication mechanism used has already read the current user for us
                retval = objCurrentUser as BaseEntity;
                if (retval == null) throw new InvalidObjectTypeException(objCurrentUser, typeof(BaseEntity));
                if (retval.Id != entityId) throw new Exception(nameof(retval) + "." + nameof(retval.Id) + " (" + retval.Id + ") != " + nameof(entityId) + " (" + entityId + ")");
            } else {
                retval = DB.GetEntityById<BaseEntity>(entityId);
                DB.SwitchIfHasEntityToRepresent(ref retval);
            }
            if (retval.AccessLevelGiven < method.PV<AccessLevel>(CoreP.AccessLevelUse.A())) {
                accessDeniedResponse = null;
                var request = new Request(Request, method, retval, exceptionHasOccurred: false);
                accessDeniedResponse = request.GetAccessDeniedResponse(nameof(currentUser) + "." + nameof(retval.AccessLevelGiven) + ") (" + retval.AccessLevelGiven + ") is less than method." + nameof(CoreP.AccessLevelUse) + " (" + method.PV<AccessLevel>(CoreP.AccessLevelUse.A()) + ")");
                currentUser = null;
                return false;
            }
            accessDeniedResponse = null;
            currentUser = retval;
            return true;
        }

        //protected abstract string GetHTMLHeading(Request request, string title, ResultCode status);
        //protected abstract string GetHTMLFooter(Request request);

        /// <summary>
        /// Fires <see cref="HandledExceptionEvent"/> and returns information about exception. 
        /// 
        /// The level of information given out to the API client is carefully balanced between 
        /// the conflicting needs of security and usability. For instance we give the 
        /// type of exception but not the message, and we do not give the stack trace,
        /// BUT, we give a link for more details (which usually needs administrative privilegies in order to access)
        /// 
        /// Also note how the code itself is carefully constructed in order to minimize or rather eliminate risk of further exceptions.
        /// </summary>
        /// <param name="ex"></param>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected object HandleExceptionAndGenerateResponse(Exception ex, [System.Runtime.CompilerServices.CallerMemberName] string caller = "") {
            HandledExceptionEvent?.Invoke(ex);
            var exceptionMessage = "";

            /// ResetEntityCache removed from code 28 Sep 2017 because does not work well with <see cref="BaseSynchronizer"/> / <see cref="CacheUse.All"/>
            // InMemoryCache.ResetEntityCache(); // Reset as a precaution

            var msg = "An internal exception of type " + Util.GetExceptionChainAsString(ex) + " occurred in " + GetType().ToStringShort() + ".\r\n" +
                    (string.IsNullOrEmpty(exceptionMessage) ? "" : "Exception message: " + exceptionMessage + ".\r\n") +
                    (string.IsNullOrEmpty(caller) ? "" : "Method that failed: " + caller + ".\r\n") +
                    "Consult log at server for more details.\r\n" +

                    /// ResetEntityCache removed from code 28 Sep 2017 because does not work well with <see cref="BaseSynchronizer"/> / <see cref="CacheUse.All"/>
                    /// "Cache has been reset as a precaution.\r\n" +

                    "If you have administrative credentials you may try the accompanying " + CoreP.ExceptionDetailsUrl;

            // Since Method.GetByControllerAndMethodName may be just the call that failed we have to be very careful here.
            if (!APIMethod.TryGetByControllerAndMethodName(GetType(), caller, out var method)) {
                return JSONView.GenerateEmergencyResult(ResultCode.exception_error,
                    "Method " + GetType() + "." + caller + " not found.\r\n" +
                    "Very unexpected.\r\n" +
                    "Unable to call " + nameof(API.Request) + "." + nameof(API.Request.GetErrorResponse) + " in order to present the following exception information:\r\n" +
                    msg);
            } else { // Preferred variant, calls JSONView.GenerateResult via Request and Result classes.
                return new Request(Request, method, currentUser: null, exceptionHasOccurred: true).GetErrorResponse(ResultCode.exception_error, msg);
            }
        }

        /// <summary>
        /// Returns id of class + method (caller) for use as <see cref="DBField.cid"/> / <see cref="DBField.vid"/> / <see cref="DBField.iid"/> 
        /// (note that usually you should use the "currentUser".id for this purpose)
        /// </summary>
        /// <param name="caller"></param>
        /// <returns></returns>
        protected long GetId(MemberInfo memberInfo) => ApplicationPart.GetClassMember(memberInfo, DB).Id;

        public class NoLoginPerformedException : ApplicationException {
            public NoLoginPerformedException(string message) : base(message) { }
        }
    }
}


