using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;
using System.Web.Http;
using AgoRapide.Database;
using AgoRapide.API;

namespace AgoRapide {

    /// <summary>
    /// TODO: The whole Method-concept needs more work, especially on documentation.
    /// 
    /// TODO: ADD SOME INITIALIZATION METHOD OR MORE ASSERTIONS
    /// (like Controller and ControllerMetod being set and so on)
    /// 
    /// TODO: Documentation and code is a little bit primitive as of Dec 2016
    /// 
    /// See also <see cref="APIMethodOrigin"/>
    /// 
    /// // TODO: THIS IS NOT CORRECT:
    /// Stored in database with <see cref="CoreP.Name"/> of <see cref="Controller"/> + "." + <see cref="ControllerMethod"/>.Name. 
    /// </summary>
    [AgoRapide(
        Description = "Represents one API method, like \"Person/Add/{first_name}/{last_name}\"",
        AccessLevelRead = AccessLevel.Anonymous,
        AccessLevelWrite = AccessLevel.System
    )]
    public class APIMethod : ApplicationPart {

        /// <summary>
        /// Note about AgoRapide concepts in general:
        /// This property <see cref="Origin"/> is an example of how to expose properties more clearly (doing it directly from outside using 
        /// <see cref="BaseEntityT.PVM"/> and 
        /// <see cref="BaseEntityT.AddPropertyM{T}(T)"/> 
        /// would have worked just as well).
        /// 
        /// TODO: Make read-only!
        /// 
        /// TODO: MOVE THIS INTO MethodAttribute-class.
        /// </summary>
        public APIMethodOrigin Origin => PVM<APIMethodOrigin>();
        public string Implementator => PV<string>(CoreP.Implementator.A());

        /// <summary>
        /// Corresponds to  IHttpRoute.MapHttpRoute.defaults.Controller (although that one is without 'Controller' i the name).
        /// Name of type is guaranteed to end with 'Controller'.
        /// 
        /// Not set for <see cref="APIMethodOrigin.Autogenerated"/>
        /// </summary>
        public Type Controller { get; private set; }

        /// <summary>
        /// The method in the Controller implementing the API functionality
        /// Corresponds to IHttpRoute.MapHttpRoute.defaults.Action
        /// 
        /// Not set for <see cref="APIMethodOrigin.Autogenerated"/>
        /// </summary>
        public System.Reflection.MethodInfo ControllerMethod { get; private set; }

        public MethodAttributeT A { get; private set; }

        /// <summary>
        /// TODO: When <see cref="AgoRapideAttribute.IsMany"/> support is finished remove this specific method
        /// TODO and access straight from Properties-collection like method.PV{List{HTTPMethod}}()
        /// TODO: (need to implement how to transfer List to / from database)
        /// </summary>
        public List<HTTPMethod> HttpMethods { get; private set; }

        public bool RequiresAuthorization => PV<bool>(CoreP.RequiresAuthorization.A());

        /// <summary>
        /// Dummy constructor for use by <see cref="IDatabase.TryGetEntityById"/>. Object meant to be discarded immediately
        /// afterwards in <see cref="ApplicationPart.GetOrAdd{T}"/>. 
        /// DO NOT USE!
        /// </summary>
        public APIMethod() {
        }

        /// <summary>
        /// Used for <see cref="APIMethodOrigin.Autogenerated"/>-methods
        /// </summary>
        /// <param name="httpMethods"></param>
        /// <param name="routeSegments"></param>
        /// <param name="routeTemplate"></param>
        public APIMethod(Type entityType, MethodAttribute methodAttribute, List<HTTPMethod> httpMethods, List<RouteSegmentClass> routeSegments, List<AgoRapideAttributeEnriched> parameters, string routeTemplate) {
            EntityType = entityType ?? throw new NullReferenceException(nameof(entityType));
            A = new MethodAttributeT(methodAttribute) ?? throw new NullReferenceException(nameof(methodAttribute));
            HttpMethods = httpMethods ?? throw new NullReferenceException(nameof(httpMethods));
            RouteSegments = routeSegments ?? throw new NullReferenceException(nameof(routeSegments));
            Parameters = parameters ?? throw new NullReferenceException(nameof(parameters));
            RouteTemplates = new List<string> { routeTemplate ?? throw new NullReferenceException(nameof(routeTemplate)) };
        }

        /// <summary>
        /// Used for <see cref="APIMethodOrigin.SemiAutogenerated"/>-methods
        /// </summary>
        /// <param name="controller"></param>
        /// <param name="controllerMethod"></param>
        /// <param name="methodAttribute"></param>
        /// <param name="httpMethods"></param>
        public APIMethod(Type controller, System.Reflection.MethodInfo controllerMethod, MethodAttribute methodAttribute, List<HTTPMethod> httpMethods) {
            Controller = controller ?? throw new ArgumentNullException(nameof(controller));
            if (!Controller.ToStringShort().EndsWith("Controller")) throw new InvalidControllernameException("'" + controller.ToStringShort() + "' does not end with 'Controller'");
            ControllerMethod = controllerMethod ?? throw new ArgumentNullException(nameof(controllerMethod));
            A = new MethodAttributeT(methodAttribute);
            HttpMethods = httpMethods ?? throw new ArgumentNullException(nameof(httpMethods));

            var detailer1 = new Func<string>(() => "\r\nerrorDetails: " + ToString());

            RouteSegments = new List<RouteSegmentClass>();
            if (A.A.S1 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S1), A.A.S1, detailer1));
            if (A.A.S2 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S2), A.A.S2, detailer1));
            if (A.A.S3 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S3), A.A.S3, detailer1));
            if (A.A.S4 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S4), A.A.S4, detailer1));
            if (A.A.S5 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S5), A.A.S5, detailer1));
            if (A.A.S6 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S6), A.A.S6, detailer1));
            if (A.A.S7 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S7), A.A.S7, detailer1));
            if (A.A.S8 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S8), A.A.S8, detailer1));
            if (A.A.S9 != null) RouteSegments.Add(new RouteSegmentClass(nameof(A.A.S9), A.A.S9, detailer1));

            switch (A.A.CoreMethod) {
                case CoreMethod.RootIndex:
                case CoreMethod.GenericMethod:
                    if (RouteSegments.Count > 0) throw new MethodAttributeInitialisationException(
                        nameof(RouteSegments) + " (like S1, S2, S3 ...) are not allowed for " + typeof(CoreMethod) + "." + A.A.CoreMethod + ". " +
                        nameof(RouteSegments) + ".Count: " + RouteSegments.Count + ". " +
                        detailer1.Result("Details: "));
                    if (!string.IsNullOrEmpty(A.A.RouteTemplate)) throw new MethodAttributeInitialisationException(
                        nameof(A.A.RouteTemplate) + " is not allowed for " + typeof(CoreMethod) + "." + A.A.CoreMethod + ". " +
                        nameof(A.A.RouteTemplate) + ": " + A.A.RouteTemplate + ". " +
                        (A.A.CoreMethod == CoreMethod.GenericMethod ? ("For " + A.A.CoreMethod + " it will default to " + typeof(Configuration) + "." + nameof(Configuration.GenericMethodRouteTemplate) + " = " + Util.Configuration.GenericMethodRouteTemplate) : "") + ". " +
                        detailer1()); break;
                default:
                    break;// OK
            }

            if (!string.IsNullOrEmpty(A.A.RouteTemplate)) {
                // TODO: Implement parsing of traditional WebAPI template
                throw new NotImplementedException(nameof(MethodAttribute) + "." + nameof(MethodAttribute.RouteTemplate) + ", " + detailer1());
            }

            Parameters = new List<AgoRapideAttributeEnriched>();

            if (RouteSegments.Count == 0) {
                switch (A.A.CoreMethod) {
                    case CoreMethod.RootIndex:
                        RouteTemplates = new List<string> { "" };
                        return; // Initialization is now complete.
                    case CoreMethod.GenericMethod:
                        RouteTemplates = new List<string> { Util.Configuration.GenericMethodRouteTemplate }; // Usually "{*url}"
                        return; // Initialization is now complete.
                    default:
                        throw new MethodInitialisationException("No " + nameof(MethodAttribute) + "." + nameof(A.A.RouteTemplate) + ", no " + nameof(RouteSegments) + " and unknown " + nameof(CoreMethod) + " (" + A.A.CoreMethod + "). Possible resolution: Remove attribute " + A.GetType().ToString() + " if not needed" + detailer1());
                }
            }

            // Continue with setting RouteTemplates, Parameters and other values:
            var parameters = ControllerMethod.GetParameters().ToList();
            parameters.ForEach(p => {
                if (!p.ParameterType.Equals(typeof(string))) throw new InvalidObjectTypeException(p.ParameterType, "Parameter " + p.ToString() + ". All parameters must have type " + typeof(string) + detailer1());
            });
            var routeTemplate = new System.Text.StringBuilder();

            var restParameters = parameters.ToDictionary(p => p.Name);
            // Check that ordering of parameters is the same, and that the names are equivalent
            RouteSegments.ForEach(s => {
                var detailer2 = new Func<string>(() => detailer1() + "\r\nRouteSegment: [" + A.GetType().ToString() + "(" + s.SegmentName + ")]");

                if (s.Type != null) {
                    routeTemplate.Append("/" + s.Type.ToStringVeryShort());
                    if (EntityType != null) throw new MethodInitialisationException(
                        "Duplicate type-definition\r\n" +
                        "(both " + s.Type + " and " + EntityType + " found)\r\n" +
                        // The first mistake (s.Type.IsEnum) is more common
                        (s.Type.IsEnum ? ("Did you write typeof(" + s.Type.ToStringShort() + ") when you really intended " + nameof(CoreP) + "." + s.Type.ToStringVeryShort() + "?\r\n") : "") +
                        // The second mistake (EntityType.IsEnum) less common
                        (EntityType.IsEnum ? ("Did you write typeof(" + EntityType.ToStringShort() + ") when you really intended " + nameof(CoreP) + "." + EntityType.ToStringVeryShort() + "?\r\n") : "") +
                        detailer2());
                    EntityType = s.Type;
                } else if (s.Parameter != null) {
                    if (s.Parameter.A.Parents != null && EntityType != null && !s.Parameter.IsParentFor(EntityType)) throw new MethodInitialisationException(
                            "Incompatible types given for " +
                            s.Parameter.GetType().ToString() + "-segment (" + EntityType + ") and " +
                            typeof(CoreP).ToString() + "." + s.Parameter.CoreP.ToString() + " (" + s.Parameter.A.Parents + ")\r\n" +
                            "You can not have " + typeof(CoreP).ToString() + "." + s.Parameter.CoreP + " " +
                            "as parameter for operations involving entities of type " + EntityType + " " +
                            "because !" + nameof(s.Parameter.IsParentFor) + "(" + EntityType + ")" + detailer2());

                    if (restParameters.Count == 0) throw new MethodInitialisationException(
                        "Too few parameters defined in source code.\r\n" +
                        "Corresponding parameter " + s.Parameter.PExplained + " for RouteSegment " +
                        "is missing for method " + ControllerMethod.Name + detailer2());
                    if (!restParameters.TryGetValue(s.Parameter.PToString, out _)) throw new MethodInitialisationException(
                        "Corresponding parameter " + s.Parameter.PExplained + " for RouteSegment " +
                        "is missing (or wrongly named) for method " + ControllerMethod.Name + ".\r\n" +
                        "Is one of the following mis-named: " + restParameters.KeysAsString() + "\r\n?\r\n" +
                        detailer2());
                    if (Parameters.Any(t => t.CoreP.Equals(s.Parameter.CoreP))) throw new MethodInitialisationException("Duplicate parameter " + typeof(CoreP).ToString() + "." + s.Parameter.CoreP + " given" + detailer2());
                    Parameters.Add(s.Parameter);
                    restParameters.Remove(s.Parameter.PToString);
                    routeTemplate.Append("/{" + s.Parameter.PToString + "}");
                    // break;
                    // case RouteSegment es:
                } else if (s.String != null) {
                    routeTemplate.Append("/" + s.String);
                } else {
                    throw new RouteSegmentClass.InvalidRouteSegmentClassException("Did not recognize any of the supposed required types" + detailer2());
                }
            });
            if (restParameters.Count > 0) throw new MethodInitialisationException("The following parameters does not have corresponding [" + A.GetType().ToString() + "(Sx = " + typeof(CoreP).ToString() + ".yyy)] initialisations: " + string.Join(", ", restParameters.Keys) + detailer1);
            var strRouteTemplate = routeTemplate.ToString();
            if (strRouteTemplate.Length > 0 && strRouteTemplate.StartsWith("/")) strRouteTemplate = strRouteTemplate.Substring(1);
            RouteTemplates = new List<string> { strRouteTemplate };
        }

        /// <summary>
        /// Consists of controller = Controller and action = MethodName
        /// </summary>
        public object Defaults {
            get {
                if (Origin == APIMethodOrigin.Autogenerated) throw new InvalidEnumException(Origin, ToString());
                return new {
                    controller = Controller.ToStringShort().Replace("Controller", ""),
                    action = ControllerMethod.Name
                };
            }
        }

        ///// <summary>
        ///// Used for internal indexation for identification
        ///// TODO: InternalKey and Name should be merged together
        ///// TODO: (but maybe InternalKey is needed as a filename-safe variant?)
        ///// </summary>
        //private string _internalKey => Controller + "." + ControllerMethod.Name;

        /// <summary>
        /// TODO: Turn this into a single string since overloads are now handled by the 
        /// TODO: <see cref="BaseController.AgoRapideGenericMethod"/> concept.
        /// 
        /// Guaranteed always set with at least one value (but for <see cref="CoreMethod.RootIndex"/> the value will usually be empty)
        /// 
        /// REST URL syntax as used by Microsoft .NET WebAPI like Person/Add/{first_name}/{last_name}
        /// For <see cref="CoreMethod.GenericMethod"/> it is usually {*url} 
        /// 
        /// Note that <see cref="Util.Configuration"/>.<see cref="Configuration.ApiPrefix"/> (normally "api/") is not present here. 
        /// It is added later by <see cref="APIMethodMapper.MapHTTPRoutes"/>
        /// </summary>
        public List<string> RouteTemplates { get; private set; }

        /// <summary>
        /// Inserts each <paramref name="parameters"/> into <see cref="RouteTemplates"/> according to <see cref="AgoRapideAttributeEnriched.ConvertObjectToString"/>
        /// </summary>
        /// <param name="parameters"></param>
        /// <returns></returns>
        public string GetAPICommand(params object[] parameters) {
            if (parameters.Length != Parameters.Count) throw new InvalidCountException(nameof(parameters) + ".Length (" + parameters.Length + ") != " + nameof(Parameters) + ".Count (" + Parameters.Count + ") for " + ToString());
            var retval = RouteTemplates[0];
            for (var i = 0; i < parameters.Length; i++) {
                if (Parameters.Count <= i) return retval;
                var key = "{" + Parameters[i].PToString + "}";
                var next = retval.Replace(key, Parameters[i].ConvertObjectToString(parameters[i]));
                if (next.Equals(retval)) throw new MethodInitialisationException(key + " not found for " + ToString());
                retval = next;
            }
            return retval;
        }

        /// <summary>
        /// Try to set Origin and Controller / ControllerMethod in a more orderly fashion, so we can remove some
        /// unnecessary checks here (especially origin)
        /// </summary>
        /// <returns></returns>
        public override string ToString() =>
            (Properties != null && Properties.ContainsKey(CoreP.APIMethodOrigin) ? (Origin.ToString() + ", ") : "") +
            (RouteTemplates != null && RouteTemplates.Count > 0 ? (RouteTemplates[0] + ", ") : "") +
            (Controller != null ? (Controller.ToStringShort() + ".") : "") +
            (ControllerMethod != null ? (ControllerMethod.Name + ", ") : "") +
            (A != null && A.A.CoreMethod != CoreMethod.None ? (nameof(CoreMethod) + "." + A.A.CoreMethod) : "");

        public class MethodInitialisationException : ApplicationException {
            public MethodInitialisationException(string message) : base(message) { }
        }

        public class InvalidRouteTemplateException : ApplicationException {
            public InvalidRouteTemplateException(string message) : base(message) { }
        }

        /// <summary>
        /// TODO: MOVE TO SEPARATE DOCUMENTATOR CLASS!
        /// 
        /// Inserts HTML links to methods within the HTML given
        /// See also InsertDocumentationURLs 
        /// </summary>
        /// <param name="html">
        /// Tip: Use the shortest route templates, like -Person/Add- since the documentation URL is the same for all overloads.
        /// </param>
        /// <returns></returns>
        public static string InsertDocumentationHTMLLinks(string html) {
            if (string.IsNullOrEmpty(html)) return html;
            throw new NotImplementedException();
            // AllMethods.ForEach(r => r.RouteTemplates.ForEach(template => html = html.Replace("-" + template + "-", r.DocumentationLink)));
        }

        /// <summary>
        /// TODO: MOVE TO SEPARATE DOCUMENTATOR CLASS!
        /// 
        /// Inserts URL to methods into text. 
        /// See also InsertDocumentationHTMLLinks
        /// 
        /// All occurrences of route templates like -Person/Add- or -Person/Add/{first_name}- will be
        /// replaced with a URL to that method's corresponding documentation.
        /// </summary>
        /// <param name="text">
        /// Tip: Use the shortest route templates, like -Person/Add- since the documentation URL is the same for all overloads.        /// </param>
        /// <returns></returns>
        public static string InsertDocumentationURLs(string text) => throw new NotImplementedException();

        ///// <summary>
        ///// TODO: MOVE TO SEPARATE DOCUMENTATOR CLASS!
        ///// 
        ///// Returns complete HTML link to documentation
        ///// 
        ///// TODO: CLEAN UP USE OF INDEXES HERE!
        ///// </summary>
        ///// <param name="methodName"></param>
        ///// <returns></returns>
        //public static string Link(string methodName) {
        //    // public static string Link(string methodName) => (_methodsNameIndex.TryGetValue(methodName, out var route)) ? route.DocumentationLink : throw new Exception("Method '" + methodName + " not found in collection MethodsToDocument");
        //    throw new NotImplementedException();
        //}

        public Type EntityType { get; private set; }

        public List<AgoRapideAttributeEnriched> Parameters { get; private set; }

        /// <summary>
        /// Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// </summary>
        protected static List<APIMethod> _allMethods = null;
        /// <summary>
        /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
        /// </summary>
        public static List<APIMethod> AllMethods => _allMethods ?? throw new NullReferenceException(nameof(_allMethods) + ", Call " + nameof(CreateSemiAutogeneratedMethods) + " first");

        /// <summary>
        /// Methods ignored because <see cref="MethodAttribute.Environment"/> does not match current <see cref="Configuration.Environment"/>
        /// </summary>
        public static List<APIMethod> IgnoredMethods = new List<APIMethod>();

        /// <summary>
        /// Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// Key is <see cref="BaseEntity.Name"/> which again is set as method.Controller.ToStringShort() + "." + method.ControllerMethod.Name
        /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
        /// </summary>
        protected static Dictionary<string, APIMethod> _allMethodsByControllerAndMethodName;
        /// <summary>
        /// Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
        /// </summary>
        // protected static SortedDictionary<string, APIMethod> _allMethodsByName = null;

        public static APIMethod GetByControllerAndMethodName(Type controller, string controllerMethodName) => TryGetByControllerAndMethodName(controller, controllerMethodName, out var retval) ? retval : throw new MethodNotFoundException("Method '" + controller + "." + controllerMethodName + "' not found");
        public static bool TryGetByControllerAndMethodName(Type controller, string controllerMethodName, out APIMethod method) {
            var dummy = AllMethods;
            return _allMethodsByControllerAndMethodName.TryGetValue(controller.ToStringShort() + "." + controllerMethodName, out method);
        }

        public static APIMethod GetByCoreMethodAndEntityType(CoreMethod coreMethod, Type entityType) => TryGetByCoreMethodAndEntityType(coreMethod, entityType, out var retval) ? retval : throw new MethodNotFoundException(coreMethod, entityType);
        protected static ConcurrentDictionary<string, APIMethod> _allMethodsByCoreMethodAndEntityType = new ConcurrentDictionary<string, APIMethod>();
        public static bool TryGetByCoreMethodAndEntityType(CoreMethod coreMethod, Type entityType, out APIMethod method) => (method = _allMethodsByCoreMethodAndEntityType.GetOrAdd(coreMethod.ToString() + entityType.ToString(), k => {
            return AllMethods.SingleOrDefault(m => m.A.A.CoreMethod == coreMethod && entityType.Equals(m.EntityType), () => nameof(coreMethod) + ": " + coreMethod + ", " + nameof(entityType) + ": " + entityType.ToStringShort());
        })) != null;

        /// <summary>
        /// This consists of the values for <see cref="MethodAttribute.S1"/> to <see cref="MethodAttribute.S9"/>. Set by <see cref="CreateSemiAutogeneratedMethods"/>
        /// </summary>
        public List<RouteSegmentClass> RouteSegments { get; private set; }

        protected static Dictionary<string, APIMethod> _allMethodsByRouteTemplate;
        /// <summary>
        /// Constructs <see cref="APIMethodOrigin.SemiAutogenerated"/>-methods.
        /// </summary>
        /// <param name="controllers"></param>
        /// <param name="attributeClassesSignifyingRequiresAuthorization">
        /// Used to set <see cref="APIMethod.RequiresAuthorization"/>.
        /// Typical values would be type of <see cref="System.Web.Http.AuthorizeAttribute"/> or 
        /// your own types like AgoRapideSample.BasicAuthenticationAttribute
        /// </param>
        /// <returns></returns>
        public static void CreateSemiAutogeneratedMethods(List<Type> controllers, List<Type> attributeClassesSignifyingRequiresAuthorization, IDatabase db) {
            _allMethods = new List<APIMethod>();
            controllers.ForEach(controller => {
                controller.GetMethods().ForEach(methodInfo => {
                    var ma = Attribute.GetCustomAttribute(methodInfo, typeof(MethodAttribute)) as MethodAttribute;
                    if (ma == null) return; // OK, just ignore this method
                    var detailer1 = new Func<string>(() => ". errorDetails: " + controller.ToString() + "." + methodInfo.Name);

                    var method = new APIMethod(
                        controller: controller,
                        controllerMethod: methodInfo,
                        methodAttribute: ma,

                        /// TODO: When <see cref="AgoRapideAttribute.IsMany"/> support is finished remove this specific method
                        /// TODO and access straight from Properties-collection like method.PV{List{HTTPMethod}}()
                        /// TODO: (need to implement how to transfer List to / from database)
                        httpMethods: new Func<List<HTTPMethod>>(() => {
                            var r = new List<HTTPMethod>();
                            if (null != Attribute.GetCustomAttribute(methodInfo, typeof(HttpGetAttribute))) r.Add(HTTPMethod.GET);
                            if (null != Attribute.GetCustomAttribute(methodInfo, typeof(HttpPostAttribute))) r.Add(HTTPMethod.POST);
                            // DELETE and PUT may be added if desired.
                            return r;
                        })()
                    );
                    /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database
                    /// TODO: no longer relevant since ConnectMethodWithDatabase is not called for them)
                    FilterConnectWithDatabaseAndAddMethod(
                        method: method,
                        origin: APIMethodOrigin.SemiAutogenerated,
                        requiresAuthorization: attributeClassesSignifyingRequiresAuthorization.Any(t => null != Attribute.GetCustomAttribute(methodInfo, t)),
                        db: db);
                });
            });
            _allMethods.ForEach(r => { // Assert valid RouteTemplates since they are set multiple places above:
                if (r.RouteTemplates == null) throw new MethodInitialisationException(nameof(RouteTemplates) + " == null for " + r.ToString());
                if (r.RouteTemplates.Count == 0) throw new MethodInitialisationException(nameof(RouteTemplates) + ".Count == 0 for " + r.ToString());
                r.RouteTemplates.ForEach(rt => {
                    if (rt == null) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " == null for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                    if (rt.Contains("//")) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " (" + rt + ") Contains (\"//\") for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                    if (rt.StartsWith("/")) throw new MethodInitialisationException("One of the " + nameof(RouteTemplates) + " (" + rt + ") StartsWith(\"/\") for " + r.ToString() + ". All " + nameof(RouteTemplates) + ": " + string.Join(",", r.RouteTemplates));
                });

            });

            /// TODO: Add GetByName / GetByInternalKey, GetByCoreMethod and corresponding TryGet...-methods
            _allMethodsByControllerAndMethodName = new Dictionary<string, APIMethod>();
            _allMethodsByRouteTemplate = new Dictionary<string, APIMethod>();
            // _allMethodsByName = new SortedDictionary<string, APIMethod>();
            _allMethods.ForEach(m => {
                _allMethodsByControllerAndMethodName.AddValue(m.Implementator, m, () => "Duplicate " + nameof(Implementator) + " (" + m.Implementator + ") has already been added to collection " + nameof(_allMethodsByControllerAndMethodName));
                _allMethodsByRouteTemplate.AddValue(m.RouteTemplates[0], m, () => "Duplicate " + nameof(m.RouteTemplates) + "[0] (" + m.RouteTemplates[0] + ") has already been added to collection " + nameof(_allMethodsByRouteTemplate));
                //if (_allMethodsByName.ContainsKey(m.Name)) throw new KeyAlreadyExistsException("Duplicate " + nameof(m.Name) + " (" + m.Name + ") has already been added to collection " + nameof(_allMethodsByName));
                //_allMethodsByName.Add(m.Name, m);
            });
        }

        /// <summary>
        /// Constructs <see cref="APIMethodOrigin.Autogenerated"/>-methods.        
        /// Adds these to <see cref="AllMethods"/>. 
        /// 
        /// TODO: MAYBE MOVE THIS METHOD SOMEWHERE ELSE
        /// TODO: DECIDE BETTER WHEN / HOW TO CALL THIS
        /// </summary>
        /// <param name="types">
        /// List of entities for which client wants standardised methods like Person/{id}, Person/{id}/AddProperty/{key}/{value}
        /// </param>
        public static void CreateAutogeneratedMethods(List<Type> types, IDatabase db) {
            if (_allMethods == null) throw new NullReferenceException(nameof(_allMethods) + ". Resolution: " + nameof(CreateSemiAutogeneratedMethods) + " must be called before " + nameof(CreateAutogeneratedMethods));

            var connector = new Action<APIMethod, bool>((method, requiresAuthorization) => {
                /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database
                /// TODO: no longer relevant since ConnectMethodWithDatabase is not called for them)
                if (_allMethodsByRouteTemplate.TryGetValue(method.RouteTemplates[0], out var existing)) throw new MethodInitialisationException(
                    method.RouteTemplates[0] + " is already implemented by " + existing.Implementator + ".\r\n" +
                    "You must either remove that implementation or remove type " + method.EntityType.ToStringShort() + " as parameter to " + System.Reflection.MethodBase.GetCurrentMethod().Name + ".\r\n" +
                    "Details for existing method: " + existing.ToString() + ".\r\n" +
                    "Details for " + APIMethodOrigin.Autogenerated + " method: " + method.ToString());
                FilterConnectWithDatabaseAndAddMethod(
                    method: method,
                    origin: APIMethodOrigin.Autogenerated,
                    requiresAuthorization: requiresAuthorization,
                    db: db);
            });

            /// Creates <see cref="CoreMethod.AddEntity"/> like Person/Add/{email}/{password}
            var addEntityCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreMethod.AddEntity + " attempt for " + t.ToStringDB());
                var obligatoryParameters = t.GetObligatoryChildProperties();
                var routeSegments = new List<RouteSegmentClass> {
                    new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                    new RouteSegmentClass("Add", "Add", detailer),
                };
                obligatoryParameters.ForEach(p => routeSegments.Add(new RouteSegmentClass(p.Value.PToString, p.Value, detailer)));
                var method = new APIMethod(
                    entityType: t,
                    methodAttribute: new MethodAttribute {
                        CoreMethod = CoreMethod.AddEntity,
                        Description =
                            "Adds an entity of type " + t.ToStringShort() + ".",
                        AccessLevelUse = t.GetAgoRapideAttributeForClass().AccessLevelWrite // Use of method equals writing of entity (creation)
                    },
                    /// TODO: MAKE SURE HTTP-METHODS ARE STORED IN DATABASE (keeping historical track of changes)
                    httpMethods: new List<HTTPMethod> { HTTPMethod.GET },
                    routeSegments: routeSegments,
                    parameters: obligatoryParameters.Values.ToList(),
                    routeTemplate: t.ToStringVeryShort() + "/Add" + string.Join("", obligatoryParameters.Select(p => "/{" + p.Value.PToString + "}"))
                    );
                connector(method, true);
            });

            /// Creates <see cref="CoreMethod.EntityIndex"/> like Person/{id}
            var entityIndexCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreMethod.EntityIndex + " attempt for " + t.ToStringDB());
                var method = new APIMethod(
                    entityType: t,
                    methodAttribute: new MethodAttribute {
                        CoreMethod = CoreMethod.EntityIndex,
                        Description =
                            "Shows entities of type " + t.ToStringShort() + " as identified by {" + CoreP.QueryId + "}.\r\n" +
                            "Usually {" + CoreP.QueryId + "} will be an integer but note how even multiple entities may be identified.",
                        AccessLevelUse = t.GetAgoRapideAttributeForClass().AccessLevelRead // Use of method equals reading of entity
                    },
                    /// TODO: MAKE SURE HTTP-METHODS ARE STORED IN DATABASE (keeping historical track of changes)
                    httpMethods: new List<HTTPMethod> { HTTPMethod.GET },
                    routeSegments: new List<RouteSegmentClass> {
                        new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                        new RouteSegmentClass(CoreP.QueryId.ToString(), CoreP.QueryId , detailer)
                    },
                    parameters: new List<AgoRapideAttributeEnriched> { CoreP.QueryId.A().Key },
                    routeTemplate: t.ToStringVeryShort() + "/{" + CoreP.QueryId + "}" // Do not use M here!
                    );
                // TODO: Create a configuration parameter deciding whether API-documentation should be available without authorization.
                // TODO: We could also change this between production and test, for instance tightening down access to 
                // TODO: API-documentation in test, while having anonymous access in production, hiding new features until launched.
                connector(method, !typeof(ApplicationPart).IsAssignableFrom(method.EntityType)); /// Note how <see cref="ApplicationPart"/> like <see cref="ClassAndMethod"/>, <see cref="EnumClass"/> and <see cref="APIMethod"/> can be read-accessed (queried) without authorization (that is, the API documentation is common available)
            });

            /// Creates <see cref="CoreMethod.UpdateProperty"/> like Person/{id}/AddProperty/{id}/{value]
            var updatePropertyCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreMethod.UpdateProperty + " attempt for " + t.ToStringDB());
                var method = new APIMethod(
                    entityType: t,
                    methodAttribute: new MethodAttribute {
                        CoreMethod = CoreMethod.UpdateProperty,
                        Description =
                            "Adds property for entities of type " + t.ToStringShort() + " as identified by {" + CoreP.QueryId + "}.\r\n" +
                            "Usually {" + CoreP.QueryId + "} will be an integer but note how even multiple entities may be identified.",
                        AccessLevelUse = t.GetAgoRapideAttributeForClass().AccessLevelWrite // Use of method equals writing to entity
                    },
                    /// TODO: MAKE SURE HTTP-METHODS ARE STORED IN DATABASE (keeping historical track of changes)
                    httpMethods: new List<HTTPMethod> { HTTPMethod.GET },
                    routeSegments: new List<RouteSegmentClass> {
                        new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                        new RouteSegmentClass(nameof(CoreP.QueryId), CoreP.QueryId , detailer),
                        new RouteSegmentClass(CoreMethod.UpdateProperty.ToString(), CoreMethod.UpdateProperty.ToString(), detailer),
                        new RouteSegmentClass(nameof(CoreP.Key), CoreP.Key , detailer),
                        new RouteSegmentClass(nameof(CoreP.Value), CoreP.Value , detailer)
                    },
                    parameters: new List<AgoRapideAttributeEnriched> {
                        CoreP.QueryId.A().Key,
                        CoreP.Key.A().Key,
                        CoreP.Value.A().Key
                    },
                    routeTemplate: t.ToStringVeryShort() + "/{" + CoreP.QueryId + "}/" + CoreMethod.UpdateProperty.ToString() + "/{" + CoreP.Key + "}/{" + CoreP.Value + "}" // Do not use M here!
                    );
                connector(method, true);
            });

            /// Creates <see cref="CoreMethod.PropertyOperation"/> like Person/{id}/AddProperty/{id}/{value]
            var propertyOperationCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreMethod.PropertyOperation + " attempt for " + t.ToStringDB());
                var method = new APIMethod(
                    entityType: t,
                    methodAttribute: new MethodAttribute {
                        CoreMethod = CoreMethod.PropertyOperation,
                        Description =
                            "Operates on property as identified by {" + CoreP.QueryId + "} with {" + nameof(PropertyOperation) + "} one of " + string.Join(", ", Util.EnumGetValues<PropertyOperation>()) + ".\r\n" +
                            "Usually {" + CoreP.QueryId + "} will be an integer but note how even multiple entities may be identified.",
                        AccessLevelUse = t.GetAgoRapideAttributeForClass().AccessLevelWrite // Use of method equals writing to entity
                    },
                    /// TODO: MAKE SURE HTTP-METHODS ARE STORED IN DATABASE (keeping historical track of changes)
                    httpMethods: new List<HTTPMethod> { HTTPMethod.GET },
                    routeSegments: new List<RouteSegmentClass> {
                        new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                        new RouteSegmentClass(nameof(CoreP.QueryId), CoreP.QueryId , detailer),
                        new RouteSegmentClass(nameof(CoreP.PropertyOperation), CoreP.PropertyOperation , detailer)
                    },
                    parameters: new List<AgoRapideAttributeEnriched> {
                        CoreP.QueryId.A().Key,
                        CoreP.PropertyOperation.A().Key
                    },
                    routeTemplate: t.ToStringVeryShort() + "/{" + CoreP.QueryId + "}/{" + CoreP.PropertyOperation + "}" // Do not use M here!
                );
                connector(method, true);
            });

            /// Creates <see cref="CoreMethod.History"/> like Person/{id}/History and Person/{id}/History
            var historyCreator = new Action<Type>(t => { // TODO: There appears to be too much duplicated code in the creators methods here
                var detailer = new Func<string>(() => APIMethodOrigin.Autogenerated + " " + CoreMethod.History + " attempt for " + t.ToStringDB());
                var method = new APIMethod(
                    entityType: t,
                    methodAttribute: new MethodAttribute {
                        CoreMethod = CoreMethod.History,
                        Description =
                            "Shows history for entity identified by {" + CoreP.IntegerQueryId + "}.",
                        AccessLevelUse = t.GetAgoRapideAttributeForClass().AccessLevelRead // Use of method equals writing to entity
                    },
                    /// TODO: MAKE SURE HTTP-METHODS ARE STORED IN DATABASE (keeping historical track of changes)
                    httpMethods: new List<HTTPMethod> { HTTPMethod.GET },
                    routeSegments: new List<RouteSegmentClass> {
                        new RouteSegmentClass(t.ToStringVeryShort(), t, detailer),
                        new RouteSegmentClass(nameof(CoreP.IntegerQueryId), CoreP.IntegerQueryId , detailer),
                        new RouteSegmentClass(nameof(CoreMethod.History), CoreMethod.History.ToString() , detailer)
                    },
                    parameters: new List<AgoRapideAttributeEnriched> {
                        CoreP.IntegerQueryId.A().Key
                    },
                    routeTemplate: t.ToStringVeryShort() + "/{" + CoreP.IntegerQueryId + "}/" + CoreMethod.History // Do not use M here!
                    );
                connector(method, true);
            });

            types.ForEach(t => {
                InvalidTypeException.AssertAssignable(t, typeof(BaseEntityT), null);
                var a = t.GetAgoRapideAttributeForClass();
                if (
                    !t.IsAbstract &&
                    !typeof(BaseEntityT).Equals(t) &&
                    !typeof(Property).IsAssignableFrom(t) && // "Independent" properties would be a meaningless concept
                    a.AccessLevelWrite < AccessLevel.System) addEntityCreator(t);
                if (a.AccessLevelRead < AccessLevel.System) entityIndexCreator(t);
                if (a.AccessLevelRead < AccessLevel.System) historyCreator(t); // Must appear before addPropertyCreator
                if (a.AccessLevelWrite < AccessLevel.System) updatePropertyCreator(t);
                if (a.AccessLevelWrite < AccessLevel.System) propertyOperationCreator(t);
            });
        }

        /// <summary>
        /// Filters (ignores) if <see cref="MethodAttribute.Environment"/> does not match <see cref="Configuration.Environment"/>
        /// (but adds to <see cref="IgnoredMethods"/> first)
        /// 
        /// "Connect" this method to the database, giving it an id and fetching historical data
        /// 
        /// TODO: Find mechanism for setting invalid for methods no longer relevant (that is, old methods resisting in database
        /// TODO: no longer relevant since ConnectMethodWithDatabase is not called for them)
        /// </summary>
        /// <param name="method"></param>
        /// <param name="db"></param>
        private static void FilterConnectWithDatabaseAndAddMethod(APIMethod method, APIMethodOrigin origin, bool requiresAuthorization, IDatabase db) {
            if (method == null) throw new NullReferenceException(nameof(method));
            if (db == null) throw new NullReferenceException(nameof(db));

            if (method.A.A.Environment < Util.Configuration.Environment) {
                IgnoredMethods.Add(method);
                return;
            }
            var cid = GetOrAdd<ClassAndMethod>(typeof(APIMethod), System.Reflection.MethodBase.GetCurrentMethod().Name, db).Id;

            if (origin == APIMethodOrigin.Autogenerated) { // Create an id that makes it easy to understand where the C# code for this method resides                
                GetOrAdd(typeof(APIMethod), typeof(BaseController).ToStringVeryShort() + ".HandleCoreMethod" + method.A.A.CoreMethod + "_for_" + method.EntityType.ToStringVeryShort() + "_(" + origin + ")", db, enrichAndReturnThisObject: method);
            } else {
                GetOrAdd(typeof(APIMethod), method.Controller.ToStringVeryShort() + "." + method.ControllerMethod.Name, db, enrichAndReturnThisObject: method);
            }

            void updater<T>(CoreP key, T value)
            { // Bug with auto formatting (CTRL-K, D)? Brace is not correct placed
                db.UpdateProperty(cid, method, key.A(), value, result: null);
            }

            switch (method.A.A.CoreMethod) {
                case CoreMethod.RootIndex: updater(CoreP.Name, "(" + method.A.A.CoreMethod + ")"); break;
                case CoreMethod.GenericMethod: updater(CoreP.Name, method.RouteTemplates[0] + " (" + method.A.A.CoreMethod + ")"); break;
                default: updater(CoreP.Name, method.RouteTemplates[0]); break;
            }
            updater(CoreP.APIMethodOrigin, origin);
            updater(CoreP.RouteTemplate, method.RouteTemplates[0]);
            if (origin == APIMethodOrigin.Autogenerated) {
                // Do not set implementator
            } else {
                updater(CoreP.Implementator, method.Controller.ToStringShort() + "." + method.ControllerMethod.Name);
            }
            updater(CoreP.RequiresAuthorization, requiresAuthorization);

            /// Construct sample URLs based on <see cref="AgoRapideAttribute.SampleValues"/> for each parameter. 
            /// Permutate between all combinations
            /// TODO: Add check for <see cref="CoreP.Key"/> and only suggest <see cref="CoreP.Value"/>, 
            /// TODO: that are valid for the given key.
            var suggestedUrls = new List<string>();
            if (method.Parameters.Count == 0) {
                suggestedUrls.Add(method.RouteTemplates[0]);
            } else if (method.Parameters.All(p => p.A.SampleValues != null && p.A.SampleValues.Length > 0)) {
                /// We have sample values for all parameters. Permutate between them
                /// TODO: Make better code than this!
                var t = method.RouteTemplates[0];
                if (method.Parameters.Count <= 0) {
                    suggestedUrls.Add(t);
                } else {
                    var p = method.Parameters[0];
                    p.A.SampleValues.ForEach(v0 => {
                        /// TODO: Make better code than this!
                        var t0 = t.Replace("{" + p.PToString + "}", v0);
                        if (method.Parameters.Count <= 1) {
                            suggestedUrls.Add(t0);
                        } else {
                            p = method.Parameters[1];
                            p.A.SampleValues.ForEach(v1 => {
                                /// TODO: Make better code than this!
                                var t1 = t0.Replace("{" + p.PToString + "}", v1);
                                if (method.Parameters.Count <= 2) {
                                    suggestedUrls.Add(t1);
                                } else {
                                    p = method.Parameters[2];
                                    p.A.SampleValues.ForEach(v2 => {
                                        /// TODO: Make better code than this!
                                        var t2 = t1.Replace("{" + p.PToString + "}", v2);
                                        if (method.Parameters.Count <= 3) {
                                            suggestedUrls.Add(t2);
                                        } else {
                                            // Add more permutations. 
                                            // TODO: Make better code than this!
                                            throw new NotImplementedException(nameof(method.Parameters) + ".Count >= 3");
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            }

            /// TODO: Add <see cref="PropertyOperation.SetInvalid"/> if already exists a <see cref="CoreP.SuggestedUrl"/>
            if (suggestedUrls.Count > 0) updater(CoreP.SuggestedUrl, string.Join("\r\n", suggestedUrls.Select(s => Util.Configuration.BaseUrl + s)));

            // Update all MethodAttribute properties
            // TDOO: MOVE THIS TO A MORE GENERAL PLACE (Into BaseEntity for instance?
            //
            // TODO: BIG WEAKNESS HERE. We do not know the generic value of what we are asking for
            // TODO: The result will be to store as DBField.strv instead of a more precise type.
            // TODO: Implement some kind of copying of properties in order to avoid this!
            // TODO: (or rather, solve the general problem of using generics with properties)
            method.A.Properties.Values.ForEach(p => {
                if (p.Key.Key.A.Type == null) {
                    throw new NullReferenceException("p.Key.Key.A.Type, details: " + p.ToString());
                } else if (p.Key.Key.A.Type.Equals(typeof(bool))) {
                    db.UpdateProperty(cid, method, p.Key, p.V<bool>(), result: null);
                    // TODO: Maybe replace this check with extension-method IsStoredAsStringInDatabase or similar...
                } else if (p.Key.Key.A.Type.Equals(typeof(Type)) || p.Key.Key.A.Type.IsEnum || p.Key.Key.A.Type.Equals(typeof(string))) {
                    var value = p.V<string>();
                    if (method.A.A.CoreMethod != CoreMethod.None) {
                        /// Add information about CoreMethod
                        /// TODO: This is very similar to <see cref="AgoRapideAttribute.EnrichFrom"/> 
                        /// TODO: We should use some of the same mechanism there.
                        var coreA = method.A.A.CoreMethod.GetAgoRapideAttributeT();
                        if (p.Key.Key.CoreP.Equals(CoreP.Description) && !string.IsNullOrEmpty(coreA.A.Description)) { // TODO: Do this in a more streamlined manner!
                            if (string.IsNullOrEmpty(value)) {
                                value = coreA.A.Description;
                            } else {
                                value += (value.EndsWith(".") ? "" : ".") + "\r\nCore " + nameof(coreA.A.Description) + ": " + coreA.A.Description;
                            }
                        } else if (p.Key.Equals(CoreP.LongDescription) && !string.IsNullOrEmpty(coreA.A.LongDescription)) { // TODO: Do this in a more streamlined manner!
                            if (string.IsNullOrEmpty(value)) {
                                value = coreA.A.LongDescription;
                            } else {
                                value += (value.EndsWith(".") ? "" : ".") + "\r\nCore " + nameof(coreA.A.LongDescription) + ": " + coreA.A.LongDescription;
                            }
                        }
                    }
                    db.UpdateProperty(cid, method, p.Key, value, result: null);
                } else {
                    throw new InvalidTypeException(p.Key.Key.A.Type, "Not implemented copying of properties. Details: " + p.ToString());
                }

            });
            _allMethods.Add(method);
        }

        public override string ToHTMLTableHeading(Request request) => "<tr><th>" + nameof(Name) + "</th><th>" + nameof(CoreMethod) + "</th><th>" + nameof(EntityType) + "</th><th>" + nameof(CoreP.Description) + "</th><th>" + nameof(Created) + "</th></tr>";

        public override string ToHTMLTableRow(Request request) => "<tr><td>" +
            (Id <= 0 ? Name.HTMLEncode() : request.CreateAPILink(this)) + "</td><td>" +
            PV(CoreP.CoreMethod.A(), CoreMethod.None).Use(c => c == CoreMethod.None ? "&nbsp;" : c.ToString()) + "</td><td>" +
            (EntityType?.ToStringVeryShort() ?? "&nbsp;") + "</td><td>" +
            PV(CoreP.Description.A(), "[NO DESCRIPTION AVAILABLE]").HTMLEncodeAndEnrich(request) + "</td><td>" +
            (RootProperty?.Created.ToString(DateTimeFormat.DateHourMin) ?? "&nbsp;") + "</td></tr>\r\n";

        public class MethodAttributeInitialisationException : ApplicationException {
            public MethodAttributeInitialisationException(string message) : base(message) { }
        }

        public class MethodNotFoundException : ApplicationException {
            public MethodNotFoundException(CoreMethod coreMethod, Type entityType) : this(nameof(coreMethod) + ": " + coreMethod + ", " + nameof(entityType) + ": " + entityType.ToStringShort()) { }
            public MethodNotFoundException(string message) : base(message) { }
        }

        public class InvalidControllernameException : ApplicationException {
            public InvalidControllernameException(string message) : base(message) { }
        }
    }
}
