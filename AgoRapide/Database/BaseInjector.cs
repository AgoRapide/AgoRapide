using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;
using System.Reflection;
using AgoRapide.API;

/// <summary>
/// Note: <see cref="AgoRapide.Database.PropertyKeyForeignKeyAggregate"/> also resides in this file for the time being (see below). 
/// </summary>
namespace AgoRapide.Database {

    /// <summary>
    /// Note <see cref="BaseInjector"/> assumes <see cref="CacheUse.All"/> for all entities involved and therefore always queries <see cref="InMemoryCache"/> directly.
    /// 
    /// TODO: Class should probably be renamed into ForeignKeyAggregatesInjecter if all other injectors are stored within <see cref="BaseSynchronizer"/>. 
    /// </summary>
    [Class(
        Description =
            "Responsible for injecting values that are only to be stored dynamically in RAM.\r\n" +
            "That is, values that are not to be stored in database, neither to be synchronized from external source.",
        LongDescription =
            nameof(BaseInjector) + " injects values that can automatically be deduced from standard AgoRapide information\r\n" +
            "(a typical example would be aggregations over foreign keys).\r\n" +
            "Inherited classes inject additional values based on their own C# logic")]
    public class BaseInjector {

        /// <summary>
        /// Note that will also set <see cref="PropertyKeyAttribute.HasLimitedRange"/> as appropriate. 
        /// 
        /// Uses <see cref="PropertyKeyExpansion"/> as generated by <see cref="GetExpansionKeys"/>
        /// </summary>
        /// <param name="type"></param>
        /// <param name="entities"></param>
        /// <param name="db"></param>
        [ClassMember(
            Description = "Calculates the actual aggregates based on keys returned by -" + nameof(GetForeignKeyAggregateKeys) + "-.",
            LongDescription = "Example: If we have Persons and Projects and every Project has a foreign key LeaderPersonId, then this method will aggregate Count_ProjectLeaderPersonid for every Person.")]
        public static void CalculateExpansions(Type type, List<BaseEntity> entities, BaseDatabase db) => type.GetChildProperties().Values.Select(key => key as PropertyKeyExpansion).Where(key => key != null).ForEach(key => {
            var hasLimitedRange = true; var valuesFound = new HashSet<string>();

            var now = DateTime.Now;
            entities.ForEach(e => { /// Note that we could possible have entities as outer loop instead, but that would loose similary with <see cref="CalculateForeignKeyAggregates"/>
                InvalidObjectTypeException.AssertAssignable(e, type);

                if (e.Properties.TryGetValue(key.SourceProperty.Key.CoreP, out var sourceProperty)) {
                    if (typeof(DateTime).Equals(key.ExpansionType.ToSourceType())) {
                        var dtmValue = sourceProperty.V<DateTime>();

                        string strValue;
                        switch (key.ExpansionType) { /// Note how AddProperty generic type now chosen must correspond to <see cref="ExpansionTypeE.ToExpandedType"/>
                            case ExpansionType.DateYear: { var v = (long)dtmValue.Year; strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateQuarter: { var v = (Quarter)(((dtmValue.Month - 1) / 3) + 1); strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateMonth: { var v = (long)dtmValue.Month; strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateWeekday: { var v = dtmValue.DayOfWeek; strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateHour: { var v = dtmValue.Hour; strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateYearQuarter: { var v = dtmValue.Year + "_" + (Quarter)(((dtmValue.Month - 1) / 3) + 1); strValue = v; e.AddProperty(key, v); break; }
                            case ExpansionType.DateYearMonth: { var v = dtmValue.Year + "_" + dtmValue.Month.ToString("00"); strValue = v; e.AddProperty(key, v); break; }
                            case ExpansionType.DateAgeDays: { var v = (long)(now.Subtract(dtmValue).TotalDays); strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateAgeWeeks: { var v = (long)(now.Subtract(dtmValue).TotalDays / 7); strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateAgeMonths: { var v = (long)(now.Subtract(dtmValue).TotalDays / 30); strValue = v.ToString(); e.AddProperty(key, v); break; }
                            case ExpansionType.DateAgeYears: { var v = (long)(now.Subtract(dtmValue).TotalDays / 365); strValue = v.ToString(); e.AddProperty(key, v); break; }
                            default: throw new InvalidEnumException(key.ExpansionType);
                        }

                        if (!valuesFound.Contains(strValue)) {
                            // TOOD: TURN LIMIT OF 20 INTO A CONFIGURATION-PARAMETER
                            if (valuesFound.Count >= 20) { // Note how we allow up to 20 DIFFERENT values, instead of values up to 20. This means that a distribution like 1,2,3,4,5,125,238,1048 still counts as limited.
                                hasLimitedRange = false;
                            } else {
                                valuesFound.Add(strValue);
                            }
                        }
                    } else {
                        throw new InvalidTypeException(key.ExpansionType.ToSourceType(), nameof(key.ExpansionType) + ": " + key.ExpansionType);
                    }
                }
            });
            key.Key.A.HasLimitedRange = hasLimitedRange; /// If TRUE then important discovery making it possible for <see cref="Result.CreateDrillDownUrls"/> to make more suggestions.
        });

        public static void CalculatePercentiles(Type type, List<BaseEntity> entities, BaseDatabase db) => type.GetChildProperties().Values.Where(key => key.Key.A.IsSuitableForPercentileCalculation).ForEach(key => {
            Percentile.Calculate(type, entities, key);
        });

        /// <summary>
        /// Note that will also set <see cref="PropertyKeyAttribute.HasLimitedRange"/> as appropriate. 
        /// 
        /// Uses <see cref="PropertyKeyForeignKeyAggregate"/> as generated by <see cref="GetForeignKeyAggregateKeys"/>
        /// </summary>
        /// <param name="type"></param>
        /// <param name="entities"></param>
        /// <param name="db"></param>
        [ClassMember(
            Description = "Calculates the actual aggregates based on keys returned by -" + nameof(GetForeignKeyAggregateKeys) + "-.",
            LongDescription = "Example: If we have Persons and Projects and every Project has a foreign key LeaderPersonId, then this method will aggregate Count_ProjectLeaderPersonid for every Person.")]
        public static void CalculateForeignKeyAggregates(Type type, List<BaseEntity> entities, BaseDatabase db) => type.GetChildProperties().Values.Select(key => key as PropertyKeyForeignKeyAggregate).Where(key => key != null).ForEach(key => {
            var hasLimitedRange = true; var valuesFound = new HashSet<long>();

            /// Build index in order to avoid O(n^2) situation.
            var toEntitiesIndex = new Dictionary<long, List<BaseEntity>>();
            InMemoryCache.EntityCache.Values.
                Where(e => key.SourceEntityType.IsAssignableFrom(e.GetType())). /// TODO: Index entities by type in entity cache, in order no to repeat queries like this:
                ForEach(e => { /// TODO: Consider implementing indices like this in <see cref="InMemoryCache"/>
                    if (e.Properties.TryGetValue(key.ForeignKeyProperty.Key.CoreP, out var p)) {
                        var foreignKeyValue = p.V<long>();
                        if (!toEntitiesIndex.TryGetValue(foreignKeyValue, out var list)) list = (toEntitiesIndex[foreignKeyValue] = new List<BaseEntity>());
                        list.Add(e);
                    }
                });

            entities.ForEach(e => {
                InvalidObjectTypeException.AssertAssignable(e, type);
                // TODO: Note potential repeated calculations of sourceEntities here. We could have used LINQ GroupBy, but would then have to
                // TODO: take into account that the ForeignKeyProperty may actually also vary, not only the SourceEntityType

                // Unuseable because O(n^2)
                // var sourceEntities = InMemoryCache.GetMatchingEntities(key.SourceEntityType, new QueryIdKeyOperatorValue(key.ForeignKeyProperty.Key, Operator.EQ, e.Id), db);

                // New variant with index created above
                var sourceEntities = toEntitiesIndex.TryGetValue(e.Id, out var temp) ? temp : new List<BaseEntity>();

                if (key.ForeignKeyProperty.Key.CoreP == key.SourceProperty.Key.CoreP) {
                    if (key.AggregationType != AggregationType.Count) throw new InvalidEnumException(key.AggregationType, "Because " + nameof(key.ForeignKeyProperty));

                    var av = (long)sourceEntities.Count;
                    e.AddProperty(key, av); // Note cast since long is the preferred type for aggregations. 

                    if (!valuesFound.Contains(av)) {
                        // TOOD: TURN LIMIT OF 30 INTO A CONFIGURATION-PARAMETER
                        // TODO: Or rather, create a LimitedRange-limit for PropertyKeyAttribute
                        if (valuesFound.Count >= 30) { // Note how we allow up to 30 DIFFERENT values, instead of values up to 20. This means that a distribution like 1,2,3,4,5,125,238,1048 still counts as limited.
                            // TODO: Or rather, create a LimitedRange-limit for PropertyKeyAttribute
                            hasLimitedRange = false;
                        } else {
                            valuesFound.Add(av);
                        }
                    }
                } else {
                    throw new NotImplementedException(key.SourceProperty.Key.PToString);
                }
            });
            key.Key.A.HasLimitedRange = hasLimitedRange; /// If TRUE then important discovery making it possible for <see cref="Result.CreateDrillDownUrls"/> to make more suggestions.
        });

        /// <summary>
        /// TODO: Move <see cref="PropertyKeyExpansion"/> into separate file, together with <see cref="BaseInjector.GetExpansionKeys"/>
        /// 
        /// Called from <see cref="PropertyKeyMapper.MapEnumFinalize"/>
        /// 
        /// Actual values are later calculated by <see cref="CalculateExpansions"/> (note that this also sets <see cref="PropertyKeyAttribute.HasLimitedRange"/> as appropriate). 
        /// <param name="keys"></param>
        /// <returns></returns>
        [ClassMember(Description =
            "Generates -" + nameof(PropertyKeyExpansion) + "- for the given keys.\r\n" +
            "Note that -" + nameof(PropertyKeyAttribute.ExpansionTypes) + "- has to be specified \"manually\" for any -" + nameof(PropertyKeyExpansion) + "- to be genereated.\r\n")]
        public static List<PropertyKeyExpansion> GetExpansionKeys(List<PropertyKey> keys) {
            Util.AssertCurrentlyStartingUp();
            var retval = new List<PropertyKeyExpansion>();

            keys.Where(k => k.Key.A.ExpansionTypes != null && k.Key.A.ExpansionTypes.Length > 0).ForEach(k => {
                k.Key.A.ExpansionTypes.ForEach(e => {
                    InvalidTypeException.AssertEquals(k.Key.A.Type, e.ToSourceType(), () => // TODO: Change to AssertAssignable, only think it through first!
                        "Illegal " + nameof(PropertyKeyAttribute) + "." + nameof(PropertyKeyAttribute.ExpansionTypes) + " (" + e + ") specified for " + k.ToString() + ".\r\n" +
                        "The specified value has a source type of " + e.ToSourceType().ToStringVeryShort() + " while the key is of type " + k.Key.A.Type.ToStringVeryShort() + ".\r\n" +
                        "Possible resolution: Delete " + nameof(PropertyKeyAttribute.ExpansionTypes) + " specified for " + k.ToString() + ".");

                    var expansionKey = new PropertyKeyExpansion(
                        e,
                        k,
                        new PropertyKeyAttributeEnrichedDyn(
                            new PropertyKeyAttribute(
                                    property: k.Key.PToString + "_" + e,
                                    description: "-" + e + "- for -" + k.Key.PToString + "-." + e.GetEnumValueAttribute().Description,
                                    longDescription: "",
                                    isMany: false
                                    ) {
                                Parents = k.Key.A.Parents,
                                Type = e.ToExpandedType(),

                                /// TODO: Note how <see cref="BaseEntity.ToHTMLTableRowHeading"/> / <see cref="BaseEntity.ToHTMLTableRow"/> uses
                                /// TODO: <see cref="Extensions.GetChildPropertiesByPriority(Type, PriorityOrder)"/> which as of Sep 2017
                                /// TODO: will not take into count access level as set here.
                                /// TOOD: (while <see cref="BaseEntity.ToHTMLDetailed"/> uses <see cref="Extensions.GetChildPropertiesForUser"/>
                                AccessLevelRead = AccessLevel.Relation // Important, make visible to user
                            },
                                (CoreP)PropertyKeyMapper.GetNextCorePId()
                            )
                        );
                    expansionKey.SetPropertyKeyWithIndexAndPropertyKeyAsIsManyParentOrTemplate(); // HACK!    
                    retval.Add(expansionKey);
                });
            });

            return retval;
        }

        /// <summary>
        /// TODO: Move <see cref="PropertyKeyForeignKeyAggregate"/> into separate file, together with <see cref="BaseInjector.GetForeignKeyAggregateKeys"/>
        /// 
        /// Called from <see cref="PropertyKeyMapper.MapEnumFinalize"/>
        /// 
        /// Actual values are later calculated by <see cref="CalculateForeignKeyAggregates"/> (note that this also sets <see cref="PropertyKeyAttribute.HasLimitedRange"/> as appropriate). 
        /// <param name="keys"></param>
        /// <returns></returns>
        [ClassMember(Description =
            "Generates -" + nameof(PropertyKeyForeignKeyAggregate) + "- for all aggregates that can automatically be deduced from standard AgoRapide information.\r\n" +
            "Will generate keys for -" + nameof(AggregationType.Count) + "- directly against foreign keys, and also keys for aggregates for all properties " +
            "for foreign entity which have -" + nameof(PropertyKeyAttribute.AggregationTypes) + "- set.\r\n")]
        public static List<PropertyKeyForeignKeyAggregate> GetForeignKeyAggregateKeys(List<PropertyKey> keys) {
            Util.AssertCurrentlyStartingUp();
            var retval = new List<PropertyKeyForeignKeyAggregate>();

            keys.Where(k => k.Key.A.ForeignKeyOf != null).ForEach(k => {
                k.Key.A.Parents.ForEach(p => { /// Note how multiple parents may share same foreign key. (Parents is guaranteed to be set now by <see cref="PropertyKeyAttributeEnriched.Initialize"/>.)
                                               /// IMPORTANT: DO NOT CALL p.GetChildProperties (That is, <see cref="Extensions.GetChildProperties"/> as value will be cached, making changes done her invisible)
                    keys.
                        Where(key => key.Key.IsParentFor(p) && (key.Key.CoreP == k.Key.CoreP || (key.Key.A.AggregationTypes != null && key.Key.A.AggregationTypes.Length > 0))).
                        ForEach(fp => { // Aggregate for all properties that are possible to aggregate over. 

                            // Added 14 Sep 2017. May have to relax a bit here though. 
                            InvalidTypeException.AssertEquals(fp.Key.A.Type, typeof(long), () => "Details: " + fp.ToString());

                            var aggregationTypes = k.Key.A.AggregationTypes.ToList();
                            if (fp.Key.CoreP == k.Key.CoreP && !aggregationTypes.Contains(AggregationType.Count)) aggregationTypes.Add(AggregationType.Count); // Always count number of foreign entities
                            aggregationTypes.ForEach(a => {
                                var foreignKeyAggregateKey = new PropertyKeyForeignKeyAggregate(
                                    a,
                                    p,
                                    k,
                                    fp,
                                    new PropertyKeyAttributeEnrichedDyn(
                                        new PropertyKeyAttribute(
                                                // Note that if there is only ONE foreignKey pointing towards entity, then identification for the foreign key can be shortened further.
                                                // (we can have (for Person) Count_Project instead of Count_Project_PersonId for instance)
                                                property: (
                                                    k.Key.A.ForeignKeyOf.ToStringVeryShort() + "_" +
                                                    a + "_" +
                                                    p.ToStringVeryShort() + "_" + fp.Key.PToString.Replace("CorrespondingInternalKey", "")). // Note removal of "CorrespondingInternalKey", resulting in shorter identification                                           
                                                    Replace(a + "_" + p.ToStringVeryShort() + "_" + p.ToStringVeryShort(), a + "_" + p.ToStringVeryShort() + "_"), // This replace will turn for instance Count_Project_ProjectLeaderPersonId into Count_Project_LeaderPersonId, that is, it shortens down aggregate keys when the P-enums repeat their parent-entity type.
                                                description: "-" + k.Key.A.ForeignKeyOf.ToStringVeryShort() + "- -" + a + "- for -" + p.ToStringVeryShort() + "- -" + fp.Key.PToString.Replace("CorrespondingInternalKey", "") + "-",
                                                longDescription: "",
                                                isMany: false
                                            ) {
                                            Parents = new Type[] { k.Key.A.ForeignKeyOf },
                                            Type = typeof(long), /// TODO: Maybe allow double also for aggregations?

                                            /// TODO: Note how <see cref="BaseEntity.ToHTMLTableRowHeading"/> / <see cref="BaseEntity.ToHTMLTableRow"/> uses
                                            /// TODO: <see cref="Extensions.GetChildPropertiesByPriority(Type, PriorityOrder)"/> which as of Sep 2017
                                            /// TODO: will not take into count access level as set here.
                                            /// TOOD: (while <see cref="BaseEntity.ToHTMLDetailed"/> uses <see cref="Extensions.GetChildPropertiesForUser"/>
                                            AccessLevelRead = AccessLevel.Relation // Important, make visible to user
                                        },
                                        (CoreP)PropertyKeyMapper.GetNextCorePId()
                                    )
                                );
                                foreignKeyAggregateKey.SetPropertyKeyWithIndexAndPropertyKeyAsIsManyParentOrTemplate(); // HACK!    
                                retval.Add(foreignKeyAggregateKey);
                            });
                        });
                });
            });
            return retval;
        }
    }

    [Class(
            Description =
                "Property key that is to be automatically injected at runtime by -" + nameof(BaseInjector) + "-.",
            LongDescription =
                "Inheriting classes:\r\n" +
                "-" + nameof(PropertyKeyForeignKeyAggregate) + "-\r\n" +
                "-" + nameof(PropertyKeyExpansion) + "-"
        )]
    public abstract class PropertyKeyInjected : PropertyKey {
        protected PropertyKeyInjected(PropertyKeyAttributeEnriched key) : base(key) { }
    }

    /// <summary>
    /// TODO: Move <see cref="PropertyKeyExpansion"/> into separate file, together with <see cref="BaseInjector.GetExpansionKeys"/>
    ///
    /// Standard describer of properties like for instance describing date 2018-12-09 as 2018_Q4. 
    /// 
    /// Pre-calculating this values, like for instance 2018_Q4 for date 2018-12-09, simplifies further querying. 
    /// </summary>
    public class PropertyKeyExpansion : PropertyKeyInjected {

        [ClassMember(Description = "Standard collection of expansion.")] // TODO: Are these needed? It is possibly better to just the few expansions actually needed. 
        public static ExpansionType[] ExpansionAllDate = new ExpansionType[] {
            ExpansionType.DateYear, ExpansionType.DateQuarter, ExpansionType.DateMonth, ExpansionType.DateWeekday, ExpansionType.DateYearQuarter, ExpansionType.DateYearMonth,
            ExpansionType.DateAgeDays, ExpansionType.DateAgeWeeks, ExpansionType.DateAgeMonths, ExpansionType.DateAgeYears };

        [ClassMember(Description = "Standard collection of expansion.")] // TODO: Are these needed? It is possibly better to just the few expansions actually needed. 
        public static ExpansionType[] ExpansionYearMonthQuarter = new ExpansionType[] {
            ExpansionType.DateYear, ExpansionType.DateQuarter, ExpansionType.DateMonth, ExpansionType.DateWeekday, ExpansionType.DateYearQuarter, ExpansionType.DateYearMonth };

        [ClassMember(Description = "Standard collection of expansion.")] // TODO: Are these needed? It is possibly better to just the few expansions actually needed. 
        public static ExpansionType[] ExpansionAge = new ExpansionType[] {
            ExpansionType.DateAgeDays, ExpansionType.DateAgeWeeks, ExpansionType.DateAgeMonths, ExpansionType.DateAgeYears };

        public ExpansionType ExpansionType { get; private set; }

        [ClassMember(Description = "This will typically be a DateTime-property.")]
        public PropertyKey SourceProperty { get; private set; }

        public PropertyKeyExpansion(ExpansionType expansionType, PropertyKey sourceProperty, PropertyKeyAttributeEnriched key) : base(key) {
            ExpansionType = expansionType;
            SourceProperty = sourceProperty;
        }
    }

    /// <summary>
    /// TODO: Move to separate file
    /// </summary>
    [Enum(AgoRapideEnumType = EnumType.EnumValue)]
    public enum ExpansionType {
        None,

        [EnumValue(Description = "Only year of date, like 2018-09-12 becoming 2018")]
        DateYear,

        [EnumValue(Description = "Only quarter of date, like 2018-09-12 becoming -" + nameof(Quarter.Q4) + "-.")]
        DateQuarter,

        [EnumValue(Description = "Only month of date, like 2018-09-12 becoming 12")]
        DateMonth,

        [EnumValue(Description = "Only weekday of date, like 2018-09-12 becoming -" + nameof(System.DayOfWeek.Sunday) + "-.")]
        DateWeekday,

        [EnumValue(Description = "Only hour of date (0-23), like 2018-09-12 07:52 becoming 7.")]
        DateHour,

        [EnumValue(Description = "Only year and quarter of date, like 2018-09-12 becoming \"2018_Q4\".")]
        DateYearQuarter,

        [EnumValue(Description = "Only year and month of date, like 2018-09-12 becoming \"2018_12\".")]
        DateYearMonth,

        [EnumValue(Description = "Less than 24 hours is 0 days, less than 48 is 1 day and so on.")]
        DateAgeDays,

        [EnumValue(Description = "Less than 7 days is 0 weeks, less than 14 days is 1 week and so on.")]
        DateAgeWeeks,

        [EnumValue(Description = "Less than 30 days is 0 months, less than 60 days is 1 month and so on (note how months are not calculcated exact as of Sep 2017).")]
        DateAgeMonths,

        [EnumValue(Description = "Less than 365 days is 0 years, less than 730 days is 1 year and so on (note how years are not calculcated exact as of Sep 2017).")]
        DateAgeYears
    }

    public enum Quarter {
        None,
        Q1,
        Q2,
        Q3,
        Q4
    }

    public static class ExpansionTypeE {
        public static Type ToExpandedType(this ExpansionType expansionType) {
            switch (expansionType) {
                case ExpansionType.DateYear: return typeof(long);
                case ExpansionType.DateQuarter: return typeof(Quarter);
                case ExpansionType.DateMonth: return typeof(long);
                case ExpansionType.DateWeekday: return typeof(DayOfWeek);
                case ExpansionType.DateHour: return typeof(long);
                case ExpansionType.DateYearQuarter: return typeof(string);
                case ExpansionType.DateYearMonth: return typeof(string);
                case ExpansionType.DateAgeDays: return typeof(long);
                case ExpansionType.DateAgeWeeks: return typeof(long);
                case ExpansionType.DateAgeMonths: return typeof(long);
                case ExpansionType.DateAgeYears: return typeof(long);
                default: throw new InvalidEnumException(expansionType);
            }
        }

        public static Type ToSourceType(this ExpansionType expansionType) {
            if (expansionType.ToString().StartsWith("Date")) {
                return typeof(DateTime);
            } else {
                throw new InvalidEnumException(expansionType);
            }
        }
    }

    /// <summary>
    /// TODO: Move <see cref="PropertyKeyForeignKeyAggregate"/> into separate file, together with <see cref="BaseInjector.GetForeignKeyAggregateKeys"/>
    /// 
    /// Created by <see cref="BaseInjector.GetForeignKeyAggregateKeys"/> (called from <see cref="PropertyKeyMapper.MapEnumFinalize"/>), and by classes inheriting <see cref="BaseInjector"/>. 
    ///
    /// Some examples of aggregations:
    /// 
    /// 1) <see cref="AggregationType.Count"/>, <see cref="Person"/>, PersonP.Count_Project_LeaderId (based on foreignKey LeaderId in Projects)
    ///    Counting number of projects that a person is the leader of.
    ///
    /// 2) <see cref="AggregationType.Sum"/>, <see cref="Person"/>, PersonP.Sum_ProjectSumBudget (based on foreignKey in Projects and Property.Budget-property)
    ///    Sum of all projects related to this person.
    ///    
    /// NOTE: <see cref="AggregationKey"/> is not to be confused with <see cref="PropertyKeyForeignKeyAggregate"/>
    /// </summary>
    [Class(Description = "Represents aggregations sourced from all entities connected to a given entity and stored as -" + nameof(PropertyKey) + "- for the given entity. ")]
    public class PropertyKeyForeignKeyAggregate : PropertyKeyInjected {

        public AggregationType AggregationType { get; private set; }
        /// <summary>
        /// Must be specified since <see cref="SourceProperty"/> may have multiple values in <see cref="PropertyKeyAttribute.Parents"/>
        /// </summary>
        public Type SourceEntityType { get; private set; }

        [ClassMember(Description = "The -" + nameof(PropertyKeyAttribute.ForeignKeyOf) + "--property of the aggregation source entity (linking the given entity and the source entity together).")]
        public PropertyKey ForeignKeyProperty { get; private set; }

        [ClassMember(Description = "This is either identical to -" + nameof(ForeignKeyProperty) + "- or it can be any other property that can be aggregated.")]
        public PropertyKey SourceProperty { get; private set; }

        /// <summary>
        /// Should only be called at application startup through <see cref="PropertyKeyMapper"/>
        /// </summary>
        /// <param name="aggregationType"></param>
        /// <param name="sourceEntityType"></param>
        /// <param name="sourceProperty"></param>
        /// <param name="key"></param>
        public PropertyKeyForeignKeyAggregate(AggregationType aggregationType, Type sourceEntityType, PropertyKey foreignKeyProperty, PropertyKey sourceProperty, PropertyKeyAttributeEnriched key) : base(key) {
            Util.AssertCurrentlyStartingUp();
            AggregationType = aggregationType;
            SourceEntityType = sourceEntityType;
            ForeignKeyProperty = foreignKeyProperty;
            SourceProperty = sourceProperty;
        }
    }
}