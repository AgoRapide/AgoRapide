// Copyright (c) 2016, 2017, 2018 Bjørn Erling Fløtten, Trondheim, Norway
// MIT licensed. Details at https://github.com/AgoRapide/AgoRapide/blob/master/LICENSE
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using AgoRapide.Core;
using System.Reflection;
using AgoRapide.API;

namespace AgoRapide.Database {

    /// <summary>
    /// TODO: Check <see cref="OpenConnection"/> and use of locking. Most probably there are issues here (Sep 2017)
    /// 
    /// TODO: For all SQL-queries, use common method for construction them and add thread-id plus calling method's name as comment at end of SQL-code
    /// TOOD: (makes for dramatically easier debugging in some cases)
    /// 
    /// TOOD: Move functionality from <see cref="PostgreSQLDatabase"/> into <see cref="BaseDatabase"/>
    /// TODO: Abstract the basic <see cref="Npgsql.NpgsqlCommand"/> and similar, in order to support multiple databases
    /// TODO: without implementing full sub classes of <see cref="BaseDatabase"/>.
    /// TOOD: (note how little implementator specific functionality is actually used, the abstraction will in other words be very easy to implement).
    /// </summary>
    [Class(Description = "PostgreSQL database implementation of -" + nameof(BaseDatabase) + "- (see that for documentation).")]
    public class PostgreSQLDatabase : BaseDatabase {

        [ClassMember(Description = "Database login role used for instance for ALTER TABLE xx OWNER TO {objectsOwner} in autogenerated SQL")]
        protected string _objectsOwner { get; private set; }

        protected string _connectionString;

        /// <summary>
        /// Always open
        /// </summary>
        protected Npgsql.NpgsqlConnection _cn1;
        // protected Npgsql.NpgsqlConnection _cn2;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="objectsOwner">See <see cref="_objectsOwner"/></param>
        /// <param name="connectionString">
        /// May be null in which case this instance will be unable to execute any queries. 
        /// Use null in when you only want to use this class for generating <see cref="SQL_CREATE_TABLE"/>. 
        /// </param>
        /// <param name="tableName">See <see cref="BaseDatabase._tableName"/></param>
        /// <param name="applicationType">See <see cref="BaseDatabase._applicationType"/></param>
        public PostgreSQLDatabase(string objectsOwner, string connectionString, string tableName, Type applicationType) : base(tableName, applicationType) {
            // Do not log connectionString (may contain password). 
            Log(nameof(objectsOwner) + ": " + objectsOwner);

            _objectsOwner = objectsOwner ?? throw new ArgumentNullException(nameof(objectsOwner));
            if (string.IsNullOrEmpty(connectionString)) {
                Log(nameof(connectionString) + " not given. This instance will be unable to execute any queries");
            } else {
                if (!connectionString.EndsWith(";")) connectionString += ";";
                if (connectionString.ToLower().Contains("applicationname")) throw new Exception("Illegal to set 'ApplicationName = ... ' in connection string (will be set by " + nameof(OpenConnection) + ")");
                _connectionString = connectionString;
                OpenConnection(out _cn1, "_cn1");
            }
        }

        public override bool TryGetEntities(BaseEntity currentUser, QueryId id, AccessType accessTypeRequired, Type requiredType, out List<BaseEntity> entities, out ErrorResponse errorResponse) {
            var logger = new Func<string>(() => nameof(currentUser) + ": " + (currentUser?.IdFriendly ?? "[NULL]") + ", " + nameof(id) + ": " + (id?.ToString() ?? throw new ArgumentNullException(nameof(id))) + ", " + nameof(accessTypeRequired) + ": " + accessTypeRequired + ", " + nameof(requiredType) + ": " + (requiredType?.ToStringShort() ?? throw new ArgumentNullException(nameof(requiredType))));

            // TOOD: Move this code into BaseDatabase
            switch (id) { /// First, check for <see cref="QueryIdContext"/> and <see cref="QueryIdInteger"/>, these can be treated directly.
                case QueryIdContext dummy1:  // TOOD: Move this code into BaseDatabase
                case QueryIdFieldIterator dummy2: {
                        Log(logger());
                        if (currentUser == null) {
                            entities = null;
                            errorResponse = new ErrorResponse(ResultCode.client_error,
                                "Unable to execute " + nameof(QueryIdContext) + " (" + id.ToString() + ") because no " + nameof(currentUser) + ". " +
                                "Possible cause: " + nameof(APIMethod.RequiresAuthorization) + " = FALSE for current method"); // TODO: Known weakness in AgoRapide as of June 2017
                            return false;
                        }

                        return TryGetContext(currentUser, id, requiredType, currentUser.PV(CoreP.Context.A(), new List<Context>()), out entities, out errorResponse);
                    }
                case QueryIdInteger q: { // TOOD: Move this code into BaseDatabase
                                         /// Note how <see cref="QueryId.SQLWhereStatement"/> is not used in this case. 
                        if (!TryGetEntityById(q.Id, requiredType, out BaseEntity temp)) { // TOOD: Move this code into BaseDatabase
                            entities = null;
                            errorResponse = new ErrorResponse(ResultCode.data_error, requiredType.ToStringVeryShort() + " with " + nameof(id) + " " + id + " not found");
                            return false;
                        }
                        if (!TryVerifyAccess(currentUser, temp, accessTypeRequired, out var strErrorResponse)) {
                            entities = null;
                            errorResponse = new ErrorResponse(ResultCode.access_error, strErrorResponse);
                            return false;
                        }
                        entities = new List<BaseEntity> { temp };
                        errorResponse = null;
                        return true;
                    }
            }

            List<BaseEntity> allEntities;

            switch (requiredType?.GetClassAttribute().CacheUse ?? CacheUse.None) {
                case CacheUse.All:
                    if (id.ToString().StartsWith("WHERE BPAPICustomerIdCorrespondingInternalKey")) {
                        var a = 1;
                        a++;
                    }
                    allEntities = InMemoryCache.GetMatchingEntities(requiredType, id, this, text => Log(text, nameof(InMemoryCache.GetMatchingEntities))); // This may be very time-consuming if synchronizing from source has to be performed.
                    break;
                default: /// Lookup in database, first step is to find all ids, then calling <see cref="BaseDatabase.GetEntityById"/> for each id
                    Log(logger());
                    Npgsql.NpgsqlCommand cmd;
                    switch (id) {
                        case QueryIdAll q: /// Use a simpler SQL query (note that calling <see cref="QueryId.SQLWhereStatement"/> would most probably result in an exception anyway)
                            cmd = new Npgsql.NpgsqlCommand(
                                "SELECT " + DBField.id + " FROM " + _tableName + " WHERE " + DBField.key + " = '" + CoreP.RootProperty + "' AND " + DBField.strv + " = '" + requiredType.ToStringDB() + "' AND\r\n" +
                                DBField.invalid + " IS NULL "
                                , _cn1
                            ); break;
                        default:
                            cmd = new Npgsql.NpgsqlCommand(
                                "SELECT DISTINCT(" + nameof(DBField.pid) + ") FROM " + _tableName + " WHERE\r\n" +
                                /// TODO: Turn <param name="requiredType"/> into ... WHERE IN ( ... ) for all known sub-classes.
                                DBField.pid + " IN\r\n" +
                                "(SELECT " + DBField.id + " FROM " + _tableName + " WHERE " + DBField.key + " = '" + CoreP.RootProperty + "' AND " + DBField.strv + " = '" + requiredType.ToStringDB() + "') AND\r\n" +
                                id.SQLWhereStatement + " AND\r\n" +
                                DBField.invalid + " IS NULL "
                                , _cn1
                            );
                            AddIdParameters(id, cmd); break;
                    }

                    if (requiredType.Equals(typeof(BaseEntity))) throw new InvalidTypeException(requiredType, "Meaningless value because the query\r\n\r\n" + cmd.CommandText + "\r\n\r\nwill never return anything");

                    /// TODO: This has room for improvement. 
                    /// TODO: Note that at least two separate queries will be executed for each and every entity in <see cref="BaseDatabase.GetEntityById"/>
                    /// TODO: Improve by reading all properties in one go, and populating entities based on this.
                    /// 
                    /// TODO: See <see cref="GetAllEntities(Type)"/> for how this was solved 19 Sep 2017
                    allEntities = ReadAllIds(cmd).Select(pid => GetEntityById(pid, requiredType)).ToList();
                    /// TODO: See <see cref="GetAllEntities(Type)"/> for how this was solved 19 Sep 2017
                    break;
            }

            Log(nameof(requiredType) + ": " + (requiredType?.ToStringVeryShort() ?? "[NULL]") + ", " + nameof(allEntities) + ".Count: " + allEntities.Count);
            id.AssertCountFound(allEntities.Count);
            var lastAccessErrorResponse = "";
            entities = allEntities.Where(e => TryVerifyAccess(currentUser, e, accessTypeRequired, out lastAccessErrorResponse)).ToList();
            if (allEntities.Count != entities.Count) Log(nameof(entities) + ".Count: " + entities.Count + " (after call to " + nameof(TryVerifyAccess) + ")");
            if (id.IsSingle) { /// Relevant for <see cref="PropertyKeyAttribute.IsUniqueInDatabase"/>
                if (allEntities.Count == 0) {
                    entities = null;
                    errorResponse = new ErrorResponse(ResultCode.data_error, requiredType.ToStringVeryShort() + " with " + nameof(id) + " " + id + " not found");
                    return false;
                } else if (entities.Count == 0 && allEntities.Count > 0) {
                    entities = null;
                    errorResponse = new ErrorResponse(ResultCode.access_error, lastAccessErrorResponse);
                    return false;
                }
                errorResponse = null;
            } else {
                /// Note how we never return <see cref="ResultCode.data_error"/> nor <see cref="ResultCode.access_error"/> 
                /// here because it would be difficult to find a consistent rationale for how to do that
                errorResponse = null;
            }
            return true;
        }

        /// <summary>
        /// TODO: Implement some LIMIT statement or throw exception if too many, or add an explanatory message
        /// </summary>
        /// <param name="entity"></param>
        /// <returns></returns>
        public override List<Property> GetEntityHistory(BaseEntity entity) {
            Log(nameof(entity.Id) + ": " + entity.Id);
            var p = entity as Property;
            var cmd = p == null ?
                new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.pid + " = " + entity.Id + " ORDER BY " + DBField.id + " DESC", _cn1) : // All history for the entity
                new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.pid + " = " + p.ParentId + " AND " + DBField.key + " = '" + p.KeyDB + "' ORDER BY " + DBField.id + " DESC", _cn1); // History for property only
                                                                                                                                                                                                 /// TODO: For p == null consider verifying access for each and every property.
            return ReadAllPropertyValues(cmd);
        }

        /// <summary>
        /// TODO: NOT YET IMPLEMENTED
        /// 
        /// Idea for implementation:
        /// </summary>
        /// <param name="currentUser"></param>
        /// <param name="entity"></param>
        /// <param name="accessTypeRequired"></param>
        /// <returns></returns>
        public override bool TryVerifyAccess(BaseEntity currentUser, BaseEntity entity, AccessType accessTypeRequired, out string errorResponse) {
            errorResponse = null;
            return true;
        }

        /// <summary>
        /// Adds the <see cref="QueryId.SQLWhereStatementParameters"/> 
        /// from <paramref name="id"/> to <paramref name="cmd"/>
        /// </summary>
        /// <param name="id"></param>
        /// <param name="cmd"></param>
        private void AddIdParameters(QueryId id, Npgsql.NpgsqlCommand cmd) =>
            id.SQLWhereStatementParameters.ForEach(p => {
                cmd.Parameters.Add(new Npgsql.NpgsqlParameter(p.key, new Func<NpgsqlTypes.NpgsqlDbType>(() => {
                    if (p.value is double) return NpgsqlTypes.NpgsqlDbType.Double;
                    if (p.value is DateTime) return NpgsqlTypes.NpgsqlDbType.Timestamp;
                    if (p.value is string) return NpgsqlTypes.NpgsqlDbType.Text;
                    throw new InvalidObjectTypeException(p.Item2, nameof(id) + ": " + id.ToString());
                })()) { Value = p.value });
            });

        public override bool TryGetEntityById(long id, Type requiredType, out BaseEntity entity) {
            /// Wait with logging. For <see cref="CacheUse.All"/> it is not wanted (it just fills up the log).
            var logText = new Func<string>(() => nameof(id) + ": " + id + ", " + nameof(requiredType) + ": " + requiredType?.ToStringShort() ?? "[NULL]");
            if (id <= 0) throw new Exception(nameof(id) + " <= 0 (" + id + "). Details: " + logText());

            var useCacheDynamically = false;
            var cacheUse = requiredType?.GetClassAttribute().CacheUse ?? CacheUse.None;
            switch (cacheUse) {
                case CacheUse.None:
                    /// TODO: 
                    /// TODO: Decide how to use <see cref="InMemoryCache"/> if <param name="requiredType"/> was null
                    /// TODO: 
                    break;
                case CacheUse.Dynamic:
                    useCacheDynamically = true; // Se code below
                    break;
                case CacheUse.All:
                    // Note exception being thrown below if not found.
                    useCacheDynamically = true;
                    break;
            }
            if (cacheUse != CacheUse.All) Log(logText());

            if (requiredType != null && typeof(Property).IsAssignableFrom(requiredType)) {
                if (cacheUse == CacheUse.All) throw new InvalidEnumException(cacheUse, "Invalid to combine with Property");
                // TODO: Should we also cache single properties?
                var retvalTemp = TryGetPropertyById(id, out var propertyTemp);
                InvalidTypeException.AssertAssignable(propertyTemp.GetType(), requiredType, () => nameof(requiredType) + " (" + requiredType + ") does not match Property type as found in database (" + propertyTemp.GetType() + ")");
                entity = propertyTemp;
                return retvalTemp;
                // throw new InvalidTypeException(requiredType, "Do not call this method for properties, use " + nameof(TryGetPropertyById) + " directly instead.");
            }

            if (useCacheDynamically && InMemoryCache.EntityCache.TryGetValue(id, out var entityTemp)) {
                entity = entityTemp;
                if (entity == null) return false;
                if (requiredType != null && !requiredType.IsAssignableFrom(entity.GetType())) throw new InvalidTypeException(entity.GetType(), requiredType, "Entity found in cache does not match required type");
                return true;
            }
            if (cacheUse == CacheUse.All) {
                // TODO: What to do here?
                // throw new InMemoryCacheException("Not found in cache");
                Log("Not found in cache: " + logText());  // At least log, since was not logged above.
            }

            if (!TryGetPropertyById(id, out var root)) {
                if (useCacheDynamically) InMemoryCache.EntityCache[id] = null;
                entity = null;
                return false;
            }

            entity = CreateEntityInMemory(requiredType, root, GetChildProperties(root));
            if (useCacheDynamically) InMemoryCache.EntityCache[id] = entity; // Note how entity itself is stored in cache, not root-property
            return true;
        }

        public override bool TryGetPropertyById(long id, out Property property) {
            Log(nameof(id) + ": " + id);
            var cmd = new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.id + " = " + id, _cn1);
            try {
                lock (GetLock(cmd)) {
                    var isManyCorrections = new List<string>();
                    using (var r = cmd.ExecuteReader()) {
                        if (!r.Read()) {
                            property = null;
                            r.Close();
                            return false;
                        }
                        property = ReadOneProperty(r, isManyCorrections);
                        if (r.Read()) throw new ExactOnePropertyNotFoundException("Multiple properties found for id " + id);
                        r.Close();
                    }
                    if (property.Key.Key.A.CanHaveChildren) property.Properties = GetChildProperties(property); // Added 13 Oct 2017, check that is correct.
                    ExecuteNonQuerySQLStatements(isManyCorrections);
                    return true;
                }
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
        }

        public override void OperateOnProperty(long? operatorId, Property property, PropertyOperation operation, Result result) {
            Log(nameof(operatorId) + ": " + (operatorId?.ToString() ?? "[NULL]") + ", " + nameof(property) + ": " + property.Id + ", " + nameof(operation) + ": " + operation);
            property.AssertIdIsSet(); var now = DateTime.Now;
            Npgsql.NpgsqlCommand cmd;
            switch (operation) {
                case PropertyOperation.SetValid:
                    cmd = new Npgsql.NpgsqlCommand("UPDATE " + _tableName + " SET " +
                        DBField.valid + " = :" + DBField.valid + ", " + // TODO: Use the database engine's clock here instead?
                        DBField.vid + " = " + (operatorId?.ToString() ?? "NULL") + " " +
                        "WHERE " + DBField.id + " = " + property.Id, _cn1);
                    cmd.Parameters.Add(new Npgsql.NpgsqlParameter(DBField.valid.ToString(), NpgsqlTypes.NpgsqlDbType.Timestamp) { Value = now }); break; // TODO: Use the database engine's clock here instead?
                case PropertyOperation.SetInvalid:
                    cmd = new Npgsql.NpgsqlCommand("UPDATE " + _tableName + " SET " +
                        DBField.invalid + " = :" + DBField.invalid + ", " + // TODO: Use the database engine's clock here instead?
                        DBField.iid + " = " + (operatorId?.ToString() ?? "NULL") + " " +
                        "WHERE " + DBField.id + " = " + property.Id, _cn1);
                    cmd.Parameters.Add(new Npgsql.NpgsqlParameter(DBField.invalid.ToString(), NpgsqlTypes.NpgsqlDbType.Timestamp) { Value = now }); break; // TODO: Use the database engine's clock here instead?
                default: throw new InvalidEnumException(operation);
            }
            ExecuteNonQuery(cmd, expectedRows: 1, doLogging: false);
            switch (operation) {
                case PropertyOperation.SetValid: // No need for removing this from cache but do adjust in-memory
                    property.Valid = now;
                    property.ValidatorId = operatorId ?? 0;
                    break;
                case PropertyOperation.SetInvalid:
                    if (property.ParentId > 0) {
                        // Remove whole of parent from cache since its initialization result may no longer be correct
                        // (It would be naive to assume that we can only remove the property itself)

                        if (InMemoryCache.EntityCache.TryRemove(property.ParentId, out var entity)) {
                            // And also remove from parent's property collection in case object exists somewhere (as a singleton class or similar)
                            if (entity.Properties != null) {
                                if (property.Key.Key.A.IsMany) {
                                    var isManyParent = entity.Properties.GetOrAddIsManyParent(property.Key);
                                    if (isManyParent.Properties.ContainsKey(property.Key.IndexAsCoreP)) {
                                        isManyParent.Properties.Remove(property.Key.IndexAsCoreP); break;
                                    }
                                } else if (entity.Properties.ContainsKey(property.Key.Key.CoreP)) {
                                    entity.Properties.Remove(property.Key.Key.CoreP); break;
                                }
                            }
                        }
                    }
                    break;
                default: throw new InvalidEnumException(operation);
            }
            result?.Count(typeof(Property), CountP.CountAffected);
        }

        public override List<long> GetRootPropertyIds(Type type) {
            Log(nameof(type) + ": " + type.ToStringShort()); /// Note how this code does not use <see cref="InMemoryCache"/> in any manner
            var cmd = new Npgsql.NpgsqlCommand(
                "SELECT " + DBField.id + " FROM " + _tableName + " WHERE " +
                DBField.key + " = '" + CoreP.RootProperty.A().Key.PToString + "' AND " +
                DBField.strv + " = '" + type.ToStringDB() + "' AND " +
                DBField.invalid + " IS NULL " +
                "ORDER BY " + DBField.id + " ASC", _cn1);
            var retval = new List<long>();
            try {
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) retval.Add(r.GetInt64(0));
                        r.Close();
                    }
                }
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            Log(nameof(retval) + ".Count: " + retval.Count);
            return retval;
        }

        public override List<Property> GetRootProperties(Type type) {
            Log(nameof(type) + ": " + type.ToStringShort()); /// Note how this code does not use <see cref="InMemoryCache"/> in any manner
            var cmd = new Npgsql.NpgsqlCommand(
                PropertySelect + "WHERE " +
                DBField.key + " = '" + CoreP.RootProperty.A().Key.PToString + "' AND " +
                DBField.strv + " = '" + type.ToStringDB() + "' AND " +
                DBField.invalid + " IS NULL " +
                "ORDER BY " + DBField.id + " ASC", _cn1);
            var retval = new List<Property>();
            var isManyCorrections = new List<string>();
            try {
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) retval.Add(ReadOneProperty(r, isManyCorrections));
                        r.Close();
                    }
                }
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            if (isManyCorrections.Count > 0) throw new InvalidCountException(isManyCorrections.Count, 0, nameof(isManyCorrections));
            Log(nameof(retval) + ".Count: " + retval.Count);
            return retval;
        }

        public override List<T> GetAllEntities<T>() {
            Log(nameof(T) + ": " + typeof(T).ToStringShort());
            //if (!typeof(ApplicationPart).IsAssignableFrom(typeof(T))) {
            //    /// For these the slow performance below is tolerable as the number of entities will be limited to an order of magnitue of 100
            //} else {
            //    /// For other objects (especially <see cref="APIDataObject"/>) the performance will be unacceptable
            //    if (DateTime.Now > DateTime.MinValue) throw new NotImplementedException("Implement in efficient manner as done with overload");
            //}
            //var retval = GetRootPropertyIds(typeof(T)).Select(id => GetEntityById<T>(id)).ToList();

            /// Note reuse of code in <see cref="GetAllEntities(Type)"/>
            var retval = GetAllEntities(typeof(T)).Select(e => e as T ?? throw new InvalidObjectTypeException(e, typeof(T))).ToList();
            Log(nameof(retval) + ".Count: " + retval.Count);
            return retval;
        }

        public override List<BaseEntity> GetAllEntities(Type type) {
            Log(nameof(type) + ": " + type.ToStringShort());

            /// Code corresponds to 
            /// <see cref="GetRootPropertyIds"/> and 
            /// <see cref="GetChildProperties"/> and
            /// <see cref="TryGetEntityById"/>
            /// TODO: IMPORTANT: USE THIS CODE ALSO IN <see cref="TryGetEntities"/> .

            var useCache = type.GetClassAttribute().CacheUse != CacheUse.None;

            var rootProperties = GetRootProperties(type);
            if (rootProperties.Count == 0) return new List<BaseEntity>(); // Fresh database / not entities created yet.

            var cmd = new Npgsql.NpgsqlCommand(PropertySelect + "WHERE " + DBField.pid + " IN (" +
                    "SELECT " + DBField.id + " FROM " + _tableName + " WHERE " + DBField.key + " = '" + CoreP.RootProperty.A().Key.PToString + "' AND " +
                    DBField.strv + " = '" + type.ToStringDB() + "' AND " +
                    DBField.invalid + " IS NULL" +
                ") " +
                "AND\r\n" +
                DBField.invalid + " IS NULL\r\n" +
                "ORDER BY " + DBField.pid + " ASC, " + DBField.id + " ASC", _cn1);

            var currentProperties = new List<Property>();
            var currentId = -1L;
            var retval = new List<BaseEntity>();
            var isManyCorrections = new List<string>();
            var noLongerCurrent = new List<Property>();
            var rootPropertyIndex = -1;

            var creatorEntityFromCurrentProperties = new Action(() => {
                rootPropertyIndex++;
                if (rootPropertyIndex >= (rootProperties.Count)) {
                    // TODO: Check this, happens if no properties for last entity???
                } else if (currentProperties.Count == 0) {
                    // No properties for new entities(?)
                } else {
                    while (rootProperties[rootPropertyIndex].Id != currentProperties[0].ParentId) {
                        // Take into consideration that there may exist entity root properties without any properties at all
                        // NOTE: THIS CODE IS COMPLICATED (SEE ALSO BELOW)
                        Log("Found root property without any properties (" + rootProperties[rootPropertyIndex].Id + ")");
                        var e = CreateEntityInMemory(type, rootProperties[rootPropertyIndex], new ConcurrentDictionary<CoreP, Property>());
                        retval.Add(e);
                        if (useCache) InMemoryCache.EntityCache[e.Id] = e;
                        rootPropertyIndex++;
                        if (rootPropertyIndex >= rootProperties.Count) throw new InvalidCountException("Root property not found for " + currentProperties[0].ParentId);
                    }
                }

                {
                    if (rootPropertyIndex >= (rootProperties.Count)) { // Added this check 20 Nov 2017. Code still is presumed to contain bugs.
                                                                       // TODO: Check this, happens if no properties for last entity???
                        if (currentProperties.Count > 0) throw new InvalidCountException("Found properties but no corresponding root-property. First property was " + currentProperties[0].Id);
                    } else {
                        var properties = OrderIntoIntoBaseEntityPropertiesCollection(currentProperties, out var thisNoLongerCurrent);
                        thisNoLongerCurrent.ForEach(p => noLongerCurrent.Add(p));
                        var e = CreateEntityInMemory(type, rootProperties[rootPropertyIndex], properties);
                        retval.Add(e);
                        if (useCache) InMemoryCache.EntityCache[e.Id] = e;
                        currentProperties.Clear();
                    }
                }
            });

            try {
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) {
                            var p = ReadOneProperty(r, isManyCorrections);
                            if (currentId == -1) {
                                // First read
                            } else if (currentId != p.ParentId) {
                                creatorEntityFromCurrentProperties();
                            }
                            currentId = p.ParentId;
                            currentProperties.Add(p);
                        }
                        r.Close();
                    }
                }
                creatorEntityFromCurrentProperties();
                while (rootPropertyIndex < (rootProperties.Count - 1)) {
                    rootPropertyIndex++;
                    // Take into consideration that there may exist entity root properties without any properties at all
                    // NOTE: THIS CODE IS COMPLICATED (SEE ALSO ABOVE)
                    Log("Found root property without any properties (" + rootProperties[rootPropertyIndex].Id + ")");
                    var e = CreateEntityInMemory(type, rootProperties[rootPropertyIndex], new ConcurrentDictionary<CoreP, Property>());
                    retval.Add(e);
                    if (useCache) InMemoryCache.EntityCache[e.Id] = e;
                }
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            ExecuteNonQuerySQLStatements(isManyCorrections);
            SetNoLongerCurrent(noLongerCurrent);

            Log(nameof(retval) + ".Count: " + retval.Count);
            return retval;
        }

        /// <summary>
        /// Populates property object with information from database
        /// </summary>
        /// <param name="r">Must be "positioned" correct, that is, this method does not call r.Read()</param>
        /// <param name="isManyCorrections">
        /// "out" parameter giving instruction about corrections to be made in database
        /// See <see cref="PropertyKeyAttribute.IsMany"/> for details about this. 
        /// </param>
        /// <returns></returns>
        protected Property ReadOneProperty(Npgsql.NpgsqlDataReader r, List<string> isManyCorrections) {
            // Log(""); Logging now generates too much data

            var id = r.GetInt64((int)DBField.id);
            // TODO: Add restriction in database so this can never be null
            var keyDB = r.IsDBNull((int)DBField.key) ? throw new PropertyKey.InvalidPropertyKeyException(
                DBField.key + " not given at all for " + nameof(DBField.id) + " = " + id + ".\r\n" +
                "Possible resolution:\r\n" +
                "  DELETE FROM " + _tableName + " WHERE " + DBField.id + " = " + id + "\r\n"
            ) : r.GetString((int)DBField.key);

            if (!PropertyKeyWithIndex.TryParse(keyDB, out var key, out var strErrorResponse, out var enumErrorResponse, out _, out var unrecognizedCoreP)) {
                switch (enumErrorResponse) {
                    case PropertyKeyWithIndex.IsManyInconsistency.IsManyButIndexNotGiven:
                        keyDB += "#1";
                        isManyCorrections.Add("UPDATE " + _tableName + " SET " + DBField.key + " = '" + keyDB + "' WHERE " + DBField.id + " = " + id);
                        Log(nameof(isManyCorrections) + ".Add(" + isManyCorrections[isManyCorrections.Count - 1]); break;
                    case PropertyKeyWithIndex.IsManyInconsistency.NotIsManyButIndexGiven:
                        keyDB = keyDB.Replace("#", "_");
                        isManyCorrections.Add("UPDATE " + _tableName + " SET " + DBField.key + " = '" + keyDB + "' WHERE " + DBField.id + " = " + id);
                        Log(nameof(isManyCorrections) + ".Add(" + isManyCorrections[isManyCorrections.Count - 1]);
                        unrecognizedCoreP = (keyDB, false); break;
                }

                if (unrecognizedCoreP != null) {
                    if (PropertyKeyMapper.TryAddA(unrecognizedCoreP.Value.unrecognizedCoreP, unrecognizedCoreP.Value.isMany,
                        unrecognizedCoreP.Value.unrecognizedCoreP + " was found as property " + id + " at " + DateTime.Now.ToString(DateTimeFormat.DateHourMin), out strErrorResponse)) {
                        // OK. New mapping succeeded.
                    } else { /// Note how errorResponse was changed by <see cref="PropertyKeyMapper.TryAddA"/> if that one was called above.
                        throw new PropertyKey.InvalidPropertyKeyException(
                           DBField.key + " invalid for " + DBField.id + " = " + id + ".\r\n" +
                           "Possible resolution:\r\n" +
                           "  DELETE FROM " + _tableName + " WHERE " + DBField.id + " = " + id + "\r\n" +
                           "Details: " + strErrorResponse
                        );
                    }
                }

                if (!PropertyKeyWithIndex.TryParse(keyDB, out key, out strErrorResponse)) throw new PropertyKey.InvalidPropertyKeyException(nameof(keyDB) + " (" + keyDB + ") is still not a valid " + typeof(PropertyKeyWithIndex) + " despite changes.\r\nDetails: " + strErrorResponse);
                if (!keyDB.Equals(key.ToString())) throw new PropertyKey.InvalidPropertyKeyException(nameof(keyDB) + " (" + keyDB + ") != " + nameof(key) + " (" + key.ToString() + ")");
            }

            var retval = Property.Create(
                key: key,
                id: id,
                created: r.GetDateTime((int)DBField.created),
                creatorId: r.IsDBNull((int)DBField.cid) ? 0 : r.GetInt64((int)DBField.cid),
                parentId: r.IsDBNull((int)DBField.pid) ? 0 : r.GetInt64((int)DBField.pid),
                foreignId: r.IsDBNull((int)DBField.fid) ? 0 : r.GetInt64((int)DBField.fid),
                keyDB: keyDB,
                lngValue: r.IsDBNull((int)DBField.lngv) ? (long?)null : r.GetInt64((int)DBField.lngv),
                dblValue: r.IsDBNull((int)DBField.dblv) ? (double?)null : r.GetDouble((int)DBField.dblv),
                blnValue: r.IsDBNull((int)DBField.blnv) ? (bool?)null : r.GetBoolean((int)DBField.blnv),
                dtmValue: r.IsDBNull((int)DBField.dtmv) ? (DateTime?)null : r.GetDateTime((int)DBField.dtmv),
                geoValue: r.IsDBNull((int)DBField.geov) ? null : r.GetString((int)DBField.geov),
                strValue: r.IsDBNull((int)DBField.strv) ? null : r.GetString((int)DBField.strv),
                valid: r.IsDBNull((int)DBField.valid) ? (DateTime?)null : r.GetDateTime((int)DBField.valid),
                validatorId: r.IsDBNull((int)DBField.vid) ? (long?)null : r.GetInt64((int)DBField.vid),
                invalid: r.IsDBNull((int)DBField.invalid) ? (DateTime?)null : r.GetDateTime((int)DBField.invalid),
                invalidatorId: r.IsDBNull((int)DBField.iid) ? (long?)null : r.GetInt64((int)DBField.iid)
            );

            if (retval.ParentId == 0) {
                /// This is an entity root property (<see cref="CoreP.RootProperty"/>). We can not put that into cache because the same id will be used
                /// to store the entity itself. We do not have any use for it either (because <see cref="CreateProperty"/> does not need it)
            } else {
                /// Note how putting properties in cache is used for invalidating cached entries by <see cref="CreateProperty"/>
                /// The cache is never used in itself when reading properties from database (<see cref="TryGetPropertyById"/> for instance will never use cache)
                /// TODO: DO THIS SMARTER. For really big databases this will just fill up memory.
                InMemoryCache.EntityCache[retval.Id] = retval;
                /// TODO: DO THIS SMARTER. For really big databases this will just fill up memory.
            }
            return retval;
        }

        /// <summary>
        /// TODO: Almost all this code can be moved into <see cref="BaseDatabase"/>
        /// </summary>
        /// <param name="username"></param>
        /// <param name="password"></param>
        /// <param name="currentUser"></param>
        /// <returns></returns>
        [ClassMember(Description =
            "Pragmatic simple and easy to understand mechanism for verification of credentials. " +
            "Only to be used in systems requiring low levels of security.")]
        public override bool TryVerifyCredentials(string username, string password, out BaseEntity currentUser) {
            // Note how password must NOT logged.
            // Log(nameof(email) + ": " + email + ", " + nameof(password) + ": " + (string.IsNullOrEmpty(password) ? "[NULL_OR_EMPTY]" : " [SET]"));

            currentUser = null;
            if (string.IsNullOrEmpty(username) || username.Length > 100) return false;
            if (string.IsNullOrEmpty(password) || password.Length > 100) return false;
            username = username.ToLower();
            Log("Searching " + CoreP.Username.A().Key.PToString + " = '" + username + "'");
            var cmd = new Npgsql.NpgsqlCommand("SELECT pid FROM " + _tableName + " WHERE " + DBField.key + " = '" + CoreP.Username.A().Key.PToString + "' AND " + DBField.strv + " = :" + CoreP.Username + " AND " + DBField.invalid + " IS NULL", _cn1);
            cmd.Parameters.Add(new Npgsql.NpgsqlParameter(CoreP.Username.ToString(), NpgsqlTypes.NpgsqlDbType.Text) { Value = username });
            if (!TryExecuteScalarLong(cmd, out var entityId)) return false;
            if (entityId == 0) return false; // Not really necessary check

            // Note that although it is expensive to read the whole entity now, a practical AgoRapide implementation would
            // probably need the whole object anyway for later purposes, and a typical Authentication mechanism could make
            // the returned object available for such purposes.
            /// (check for instance code in <see cref="BasicAuthenticationAttribute.AuthenticateAsync"/>)
            //    context.Request.Properties["AgoRapideCurrentUser"] = currentUser
            // )
            if (!TryGetEntityById(entityId, requiredType: null, entity: out currentUser)) return false;

            if (currentUser.PV(CoreP.Username.A(), "") != username) { // Read log text carefully. It is only AFTER call to TryGetEntityById that current was set to FALSE for old properties. In other words, it is normal to read another email now 
                Log(
                    "It looks like " + CoreP.Username.A().Key.A.EnumValueExplained + " " +
                    "was just changed for entity " + currentUser.Id + " " +
                    "resulting in more than one current property in database. " +
                    "Returning FALSE now " +
                    "since the last one (the one now current) (" + currentUser.PV(CoreP.Username.A(), "") + ") " +
                    "does not correspond to the one given (" + username + ")");
                return false;
            }

            if (!currentUser.Properties.TryGetValue(CoreP.Password.A().Key.CoreP, out var pPassword)) {
                Log("Password does not exist for " + currentUser.ToString());
                return false;
            }
            /// Now how we must access <see cref="Property.Value"/> instead of <see cref="Property.V{T}"/> because that latter will only give us [SET] as value
            var correctPasswordHashedWithSalt = pPassword.Value as string ?? throw new InvalidObjectTypeException(pPassword.Value, typeof(string), pPassword.ToString());
            if (string.Empty.Equals(correctPasswordHashedWithSalt)) {
                Log("Password has empty value for " + currentUser.ToString());
                return false;
            }
            if (password.Equals(correctPasswordHashedWithSalt)) throw new InvalidPasswordException<CoreP>(CoreP.Password, nameof(password) + ".Equals(" + nameof(correctPasswordHashedWithSalt) + "). Either 1) Password was not correct stored in database (check that " + nameof(CreateProperty) + " really salts and hashes passwords), or 2) The caller actually supplied an already salted and hashed password.");

            // NOTE: OAuth or similar would give better performance. Now we have to calculate the hash value for every authentication attempt.
            // TODO: Consider caching hashed value found. 
            var passwordHashedWithSalt = Util.GeneratePasswordHashWithSalt(currentUser.Id, password);
            if (correctPasswordHashedWithSalt != passwordHashedWithSalt) {
                // A bit expensive to store in database, but useful information. 
                // Note how the NUMBER of failed attempts are not logged since only the (last) valid-date in the database is stored for repeated failures. 
                // Note that if you are concerned about hacking / DDOS scenarios or similar you should definitely implement a more robust authentication mechanism.
                UpdateProperty(GetId(MethodBase.GetCurrentMethod()), currentUser, CoreP.AuthResult.A(), value: false, result: null);
                return false;
            }

            if (currentUser.Properties.TryGetValue(CoreP.RejectCredentialsNextTime.A().Key.CoreP, out var p)) {
                OperateOnProperty(GetId(MethodBase.GetCurrentMethod()), p, PropertyOperation.SetInvalid, null);
                if (p.V<bool>()) return false;
            }

            Log("Returning TRUE");
            // Note how the NUMBER of successful attempts are not logged since only the (last) valid-date in the database is stored for repeated successes. 
            // TODO: Instead of just using cid = currentUser.Id let this class discover its own id used as cid and iid
            UpdateProperty(GetId(MethodBase.GetCurrentMethod()), currentUser, CoreP.AuthResult.A(), value: true, result: null);

            SwitchIfHasEntityToRepresent(ref currentUser);
            return true;
        }

        public override bool TryAssertUniqueness(PropertyKeyWithIndex a, object value, out Property existingProperty, out string errorResponse) {
            var key = a.Key.CoreP;
            Log(nameof(key) + ": " + key + ", " + nameof(value) + ": " + value);
            a.Key.A.AssertIsUniqueInDatabase();

            // TODO: DUPLICATED CODE!
            var defaultKeyToString = key.ToString();
            // TODO: Add support for IsMany. Make possible to store key as #1, #2 and so on in database.
            var keyAsString = a.Key.PToString;

            Npgsql.NpgsqlCommand cmd;
            switch (value) {
                /// TODO: This code is surely duplicated somewhere else                    
                /// Typical is <see cref="CoreP.IsAnonymous"/>
                case string strValue:
                    cmd = new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.key + " = '" + keyAsString + "' AND " + DBField.strv + " ILIKE :" + DBField.strv + " AND " + DBField.invalid + " IS NULL", _cn1);
                    cmd.Parameters.Add(new Npgsql.NpgsqlParameter(DBField.strv.ToString(), NpgsqlTypes.NpgsqlDbType.Text) { Value = strValue }); break;
                case bool blnValue:
                    cmd = new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.key + " = '" + keyAsString + "' AND " + DBField.blnv + " = " + (blnValue ? "TRUE" : "FALSE") + " AND " + DBField.invalid + " IS NULL", _cn1); break;
                case QueryId queryIdValue:
                    cmd = new Npgsql.NpgsqlCommand(PropertySelect + " WHERE " + DBField.key + " = '" + keyAsString + "' AND " + DBField.strv + " = :" + DBField.strv + " AND " + DBField.invalid + " IS NULL", _cn1);
                    cmd.Parameters.Add(new Npgsql.NpgsqlParameter(DBField.strv.ToString(), NpgsqlTypes.NpgsqlDbType.Text) { Value = queryIdValue.ToString() });
                    break;
                default: throw new InvalidObjectTypeException(value, nameof(a.Key.A.IsUniqueInDatabase) + " only implemented for string and bool");
            }
            var existing = ReadAllPropertyValues(cmd);
            switch (existing.Count) {
                case 0:
                    existingProperty = null;
                    errorResponse = null;
                    return true;
                case 1:
                    existingProperty = existing[0];
                    errorResponse = nameof(a.Key.A.IsUniqueInDatabase) + " property " + keyAsString + " = '" + value + "' already exists in database. You must chose a different value for " + keyAsString + ".";
                    return false;
                default:
                    throw new UniquenessException(
                        "Found " + existing.Count + " existing properties for " + nameof(a.Key.A.IsUniqueInDatabase) + " property " + keyAsString + " = '" + value + "'\r\n" +
                        "Expected at most only one existing property.\r\n" +
                        "Resolution: Delete from database all but one of the existing properties with the following SQL expression:\r\n" +
                        "  DELETE FROM " + _tableName + " WHERE id IN (" + string.Join(", ", existing.Select(p => p.Id)) + ")\r\n" +
                        "The actual existing properties are:\r\n" +
                        string.Join("\r\n", existing.Select(p => p.ToString())));
            }
        }

        public override long CreateProperty(long? cid, long? pid, long? fid, PropertyKeyWithIndex key, object value, Result result) {
            Npgsql.NpgsqlCommand cmd;
            if (key.Key.A.IsUniqueInDatabase) {
                if (key.Key.A.IsMany) throw new NotImplementedException(nameof(key.Key.A.IsMany) + " when " + nameof(key.Key.A.IsUniqueInDatabase));
                AssertUniqueness(key, value);
            }
            if (cid == null) Util.AssertCurrentlyStartingUp();

            var idStrings = new Func<(string logtext, string names, string values)>(() => {
                if (cid == null && pid == null && fid == null) {
                    Log(nameof(cid) + ", " + nameof(pid) + " and " + nameof(fid) + " are all null. Setting " + nameof(cid) + " = 0. " +
                        "This should only occur once for your database in order for " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetClassMember) + " to create an instance 'for itself'. " +
                        "In all other instances of calls to " + MethodBase.GetCurrentMethod().Name + " it should be possible to at least have a value for " + nameof(cid) + " (creatorId) " +
                        "(by using " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetClassMember) + "). " +
                        "In other words, this log message should never repeat itself", result);
                    cid = 0;
                }
                if (cid != null && pid == null && fid == null) return (
                    // item1 is logtext
                    nameof(cid) + ": " + cid,
                    // item2 is {names} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + DBField.cid,
                    // item3 is {values} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + cid.ToString()
                );
                if (cid != null && pid != null && fid == null) return (
                    // item1 is logtext
                    nameof(cid) + ": " + cid +
                    ", " + nameof(pid) + ": " + pid,
                    // item2 is {names} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + DBField.cid +
                    ", " + DBField.pid,
                    // item3 is {values} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + cid.ToString() +
                    ", " + pid.ToString()
                );
                if (cid != null && pid != null && fid != null) return (
                    // item1 is logtext
                    nameof(cid) + ": " + cid +
                    ", " + nameof(pid) + ": " + pid +
                    ", " + nameof(fid) + ": " + fid,
                    // item2 is {names} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + DBField.cid +
                    ", " + DBField.pid +
                    ", " + DBField.fid,
                    // item3 is {values} to put into INSERT INTO p({names}) VALUES({values})
                    ", " + cid.ToString() +
                    ", " + pid.ToString() +
                    ", " + fid.ToString()
                );
                throw new NotImplementedException(
                    "For the time being either " +
                    "1) Only parameter " + nameof(cid) + " or " +
                    "2) Two parameters (" + nameof(cid) + ", " + nameof(pid) + "), or " +
                    "3) All parameters (" + nameof(cid) + ", " + nameof(pid) + ", " + nameof(fid) + "), " +
                    "must be given, not " + (cid == null ? " " : nameof(cid)) + (pid == null ? " " : nameof(pid)) + (fid == null ? " " : nameof(fid)));
            })();

            Log(idStrings.logtext +
                ", " + nameof(key) + ": " + key.ToString() +
                ", " + nameof(value) + ": " + (key.Key.A.IsPassword ? "[WITHHELD]" : value.ToString()), result);
            var type = value.GetType();

            // TODO: Idea for performance improvement. We could read some sequence values in a separate
            // TODO: thread and store them in a concurrent queue for later thread safe retrieval
            cmd = new Npgsql.NpgsqlCommand("SELECT nextval('" + SEQUENCE_NAME + "')", _cn1);
            var id = ExecuteScalarLong(cmd, () => cmd.CommandText);

            var valueStrings = new Func<(string nameOfDbField, string valueOrParameter, NpgsqlTypes.NpgsqlDbType? dbType)>(() => {
                switch (value) {
                    case long _long: return (nameof(DBField.lngv), "'" + _long.ToString() + "'", null);
                    case double _dbl: return (nameof(DBField.dblv), ":" + nameof(DBField.dblv), NpgsqlTypes.NpgsqlDbType.Double); // Leave conversion to Npgsql
                    case bool _bln: return (nameof(DBField.blnv), _bln ? "TRUE" : "FALSE", null);
                    case DateTime _dtm: return (nameof(DBField.dtmv), ":" + nameof(DBField.dtmv), NpgsqlTypes.NpgsqlDbType.Timestamp); // Leave conversion to Npgsql
                    case Type _type: return (nameof(DBField.strv), "'" + _type.ToStringDB() + "'", null); // Considered SQL injection safe
                    default:
                        if (value.GetType().IsEnum) return (nameof(DBField.strv), "'" + value.ToString() + "'", null); // Considered SQL injection safe
                        var _typeDescriber = value as ITypeDescriber;
                        if (_typeDescriber != null) value = value.ToString();
                        value = value.ToString(); /// We have to trust that the ToString representation is possible to reconstruct from the String value. Unknown type of object, maybe <see cref="System.Uri"/> for instance.
                        // if (!(value is string)) throw new InvalidObjectTypeException(value, typeof(string));
                        return (nameof(DBField.strv), ":" + nameof(DBField.strv), NpgsqlTypes.NpgsqlDbType.Text); // Leave conversion to Npgsql (because of SQL injection issues)
                }
            })();

            // Log("Storing as " + valueStrings.nameOfDbField + ", " + valueStrings.valueOrParameter, result); // REMOVED LOGGING 22 SEP 2017

            // Note how we do not bother with parameters for object types which do not have any SQL injection issues.
            cmd = new Npgsql.NpgsqlCommand("INSERT INTO p\r\n" +
                "(" + DBField.id + idStrings.names + ", " + DBField.key + ", " + valueStrings.nameOfDbField + ")\r\n" +
                "VALUES (" + id + idStrings.values + ", '" + key.ToString() + "', " + valueStrings.valueOrParameter + ")", _cn1);

            if (valueStrings.valueOrParameter.StartsWith(":")) {
                if (valueStrings.dbType == null) throw new NullReferenceException(nameof(valueStrings) + "." + nameof(valueStrings.dbType) + ". Must be set when " + nameof(valueStrings) + "." + nameof(valueStrings.valueOrParameter) + ".StartsWith(\":\") (" + valueStrings.valueOrParameter + ")");
                cmd.Parameters.Add(new Npgsql.NpgsqlParameter(valueStrings.valueOrParameter, valueStrings.dbType) {
                    Value = new Func<object>(() => {
                        if (!key.Key.A.IsPassword) return value;
                        // salt and hash
                        if (pid == null) throw new ArgumentNullException(nameof(pid) + " must be set for " + nameof(PropertyKeyAttribute) + "." + nameof(PropertyKeyAttribute.IsPassword));
                        if (!(value is string)) throw new InvalidObjectTypeException(value, typeof(string), "Only string is allowed for " + nameof(PropertyKeyAttribute) + "." + nameof(PropertyKeyAttribute.IsPassword));
                        return Util.GeneratePasswordHashWithSalt((long)pid, (string)value);
                    })()
                });
            } else {
                if (valueStrings.dbType != null) throw new NotNullReferenceException(nameof(valueStrings) + "." + nameof(valueStrings.dbType) + ". Must not be set when !" + nameof(valueStrings) + "." + nameof(valueStrings.valueOrParameter) + ".StartsWith(\":\") (" + valueStrings.valueOrParameter + ")");
                if (key.Key.A.IsPassword) throw new Exception(nameof(PropertyKeyAttribute) + "." + nameof(key.Key.A.IsPassword) + " only valid for strings, not " + value.GetType());
            }
            var propertiesAffected = ExecuteNonQuery(cmd, expectedRows: 1, doLogging: false);
            result?.Count(typeof(Property), CountP.CountCreated);
            result?.Count(typeof(Property), CountP.CountTotal); // TODO: Are we sure about this?
            return id;
        }

        public override ConcurrentDictionary<CoreP, Property> GetChildProperties(Property parentProperty) {
            if (!parentProperty.Key.Key.A.CanHaveChildren) return null;
            Log(nameof(parentProperty.Id) + ": " + parentProperty.Id);
            // parentProperty.Key.Key.A.AssertCanHaveChildren();
            var cmd = new Npgsql.NpgsqlCommand(PropertySelect + " WHERE\r\n" +
                // TODO: CHECK IF THIS IS STILL THE CORRECT METHOD
                "(\r\n" +
                "  " + DBField.pid + " = " + parentProperty.Id + " " +

                /// June 2017: Giving up on reading fid will result in <see cref="PropertyOperation.SetInvalid"/> if multiple found.
                //"OR (\r\n" +                                               // pid IS NOT NULl and fid = parent is for limiting to relations
                //"    (" + DBField.pid + " IS NOT NULL) AND\r\n" +                        // where this entity is the foreign entity. Note the  
                //"    (" + DBField.fid + " = " + parentProperty.Id + ")\r\n" +            // careful construct because we DO NOT WANT root-properties
                //                                                                         // TODO: Consider adding AND name LIKE 
                //                                                                         // 'Relation%' here as an additional measure
                //"  )\r\n" +                                              // where we are indicated as QueryCompoent to be included
                ") " +

                "AND\r\n" +                                            // (that would result in lots of properties being set no-longer-current)
                DBField.invalid + " IS NULL\r\n" +
                "ORDER BY " + DBField.id + " ASC", _cn1);
            return ReadAllPropertyValuesAndInvalidateDuplicates(cmd);
        }

        /// <summary>
        /// Executes the given SQL statements (if any given)
        /// </summary>
        /// <param name="sqlStatements">
        /// Each statement is expected to affect exactly one row. 
        /// </param>
        private void ExecuteNonQuerySQLStatements(List<string> sqlStatements) =>
            sqlStatements.ForEach(s => {
                Log(s);
                ExecuteNonQuery(new Npgsql.NpgsqlCommand(s, _cn1), expectedRows: 1, doLogging: true);
            });

        protected long ExecuteScalarLong(Npgsql.NpgsqlCommand cmd, Func<string> detailer) => TryExecuteScalarLong(cmd, out var retval) ? retval : throw new NoResultFromDatabaseException(nameof(cmd) + "." + nameof(cmd.CommandText) + ": " + cmd.CommandText + detailer.Result("\r\nDetails: "));
        protected bool TryExecuteScalarLong(Npgsql.NpgsqlCommand cmd, out long _long) {
            lock (GetLock(cmd)) {
                object retval;
                try {
                    retval = cmd.ExecuteScalar();
                } catch (Exception ex) {
                    throw new PostgreSQLDatabaseException(cmd, ex);
                }
                if ((retval == null) || (retval is DBNull)) {
                    _long = default(long);
                    return false;
                }
                _long = (retval as long? ?? throw new InvalidObjectTypeException(retval, typeof(long)));
                return true;
            }
        }

        private int ExecuteNonQuery(Npgsql.NpgsqlCommand cmd) => TryExecuteNonQuery(cmd, -1, true, out var retval) ? retval : retval;
        private int ExecuteNonQuery(Npgsql.NpgsqlCommand cmd, bool doLogging) => TryExecuteNonQuery(cmd, -1, doLogging, out var retval) ? retval : retval;
        private int ExecuteNonQuery(Npgsql.NpgsqlCommand cmd, int expectedRows, bool doLogging) => TryExecuteNonQuery(cmd, expectedRows, doLogging, out var retval) ? retval : throw new UnexpectedNumberOfRowsException(retval, expectedRows);
        /// <summary>
        /// Returns false if <paramref name="affectedRows"/> does not correspond to <paramref name="expectedRows"/>
        /// </summary>
        /// <param name="cmd"></param>
        /// <param name="expectedRows">Will always be set regardless of returned value</param>
        /// <param name="doLogging"></param>
        /// <param name="affectedRows"></param>
        private bool TryExecuteNonQuery(Npgsql.NpgsqlCommand cmd, int expectedRows, bool doLogging, out int affectedRows) {
            lock (GetLock(cmd)) {
                try {
                    affectedRows = cmd.ExecuteNonQuery();
                } catch (Exception ex) {
                    throw new PostgreSQLDatabaseException(cmd, nameof(expectedRows) + ": " + expectedRows, ex);
                }
            }
            if (doLogging) Log(nameof(affectedRows) + ": " + affectedRows);
            return affectedRows == expectedRows;
        }

        public List<int> ReadAllIds(Npgsql.NpgsqlCommand cmd) {
            // TODO: Decide on logging here. What to log.
            Log("\r\n" + nameof(cmd.CommandText) + ":\r\n" + cmd.CommandText + "\r\n" + nameof(cmd.Parameters) + ".Count: " + cmd.Parameters.Count);
            var retval = new List<int>();
            try {
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) retval.Add(r.GetInt32(0));
                        r.Close();
                    }
                }
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            return retval;
        }

        protected List<Property> ReadAllPropertyValues(Npgsql.NpgsqlCommand cmd) {
            var retval = new List<Property>();
            try {
                var isManyCorrections = new List<string>();
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) retval.Add(ReadOneProperty(r, isManyCorrections));
                        r.Close();
                    }
                }
                ExecuteNonQuerySQLStatements(isManyCorrections);
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            return retval;
        }

        [ClassMember(
            Description =
                "For any duplicates the first property's -" + nameof(Property.Invalid) + "- will be set to -" + nameof(DateTime.Now) + "- " +
                "and that property will be excluded from the returned dictionary.",
            LongDescription =
                "It is therefore important to always read properties in ASCending order from database before calling this method"
        )]
        protected ConcurrentDictionary<CoreP, Property> ReadAllPropertyValuesAndInvalidateDuplicates(Npgsql.NpgsqlCommand cmd) {
            var properties = new List<Property>();
            var isManyCorrections = new List<string>();
            try {
                lock (GetLock(cmd)) {
                    using (var r = cmd.ExecuteReader()) {
                        while (r.Read()) {
                            properties.Add(ReadOneProperty(r, isManyCorrections));
                        }
                        r.Close();
                    }
                }
                ExecuteNonQuerySQLStatements(isManyCorrections);
            } catch (Exception ex) {
                throw new PostgreSQLDatabaseException(cmd, ex);
            }
            /// This somewhat convoluted apporach is due to reusing functionality in <see cref="GetAllEntities(Type)"/>
            var retval = OrderIntoIntoBaseEntityPropertiesCollection(properties, out var noLongerCurrent);
            SetNoLongerCurrent(noLongerCurrent);
            return retval;
        }

        /// <summary>
        /// TODO: Change to use separate lock for each connection
        /// </summary>
        protected static string connectionOpenerLock = "";

        /// <summary>
        /// Tip: In PostgreSQL you can check open connections with SELECT * FROM pg_stat_activity;
        ///
        /// Code is a bit primitive. Check issues regarding connection pooling for instance.
        /// Note that Dispose is recommended to always call
        /// </summary>
        /// <param name="cn"></param>
        protected void OpenConnection(out Npgsql.NpgsqlConnection cn, string id) {
            Log(id);
            lock (connectionOpenerLock) { // TODO: CHECK USE OF LOCKING
                var stage = "";
                try {
                    stage = "new Npgsql.NpgsqlConnection";
                    cn = new Npgsql.NpgsqlConnection(_connectionString + "ApplicationName=" + _applicationType + " PID " + System.Diagnostics.Process.GetCurrentProcess().Id + " thread " + System.Threading.Thread.CurrentThread.ManagedThreadId + " " + id);
                    stage = "Open";
                    cn.Open();
                } catch (Exception ex) {
                    cn = null;
                    var exOuter = new OpenDatabaseConnectionException(MethodBase.GetCurrentMethod().Name + " for " + id + " failed at stage " + stage + " because of " + ex.GetType().ToString() + " with message " + ex.Message + " (see " + nameof(ex.InnerException) + " for more details)", ex);
                    HandleException(exOuter);
                    throw exOuter;
                }
            }
        }

        private string _SEQUENCE_NAME;
        public string SEQUENCE_NAME => _SEQUENCE_NAME ?? (_SEQUENCE_NAME = "sequence_" + _tableName + "_" + DBField.id);

        private string _SQL_CREATE_TABLE;
        /// <summary>
        /// TODO: Create as abstract property in <see cref="BaseDatabase"/>
        /// 
        /// TODO: (Or, even bette) Ensure that all SQL is standard, and just move into <see cref="BaseDatabase"/>
        /// 
        /// TODO: Split this into List{string} of SQL-statements (or maybe a Dictionary and some kind of auto-discovery for missing elements in the database). 
        /// TODO: In other words, check for existence of each and every element at startup and run the corresponding SQL code to initialize them.
        /// 
        /// TODO: At startup we could always update the comments? Or not? There is a SQL injection risk here (although coming from our own source code)
        /// TODO: If you choose to always update comments you should create some kind of absolutely SQL-safe string by using white listed characters. (A-Z, a-z, 1-9, _ or similar)
        /// 
        /// Returns SQL for CREATE TABLE command. 
        /// Mapping of data types between PostgreSQL and .NET:
        ///   long     = bigint
        ///   double   = double
        ///   bool     = boolean
        ///   DateTime = timestamp without time zone
        ///   string   = text
        /// </summary>
        public string SQL_CREATE_TABLE => _SQL_CREATE_TABLE ?? (_SQL_CREATE_TABLE = new Func<string>(() => {
            // makeSQLSafe is a quite quick and dirty implementation. Do not use elsewhere!
            var makeSQLSafe = new Func<string, string>(s => s.Replace(";", ":").Replace("--", "__").Replace("\r", "/").Replace("\n", "/").Replace("'", "`").Replace("\"", "`"));
            return "CREATE TABLE " + _tableName + "\r\n(\r\n" +
            string.Join("\r\n", Util.EnumGetValues((DBField)(-1)).Select(f => {
                return "  " + f.ToString() + " " + new Func<string>(() => {
                    var a = f.A();
                    var postfix = new Func<string>(() => {
                        switch (f) {
                            case DBField.id:
                            case DBField.cid: return " NOT NULL,";
                            case DBField.created: return " DEFAULT now(),"; /// TODO: Should we add these as <see cref="PropertyKeyAttribute"/>?
                            default: return ",";
                        }
                    })();
                    if (a.Key.A.Type.Equals(typeof(long))) return "bigint" + postfix;
                    if (a.Key.A.Type.Equals(typeof(double))) return "double precision" + postfix;
                    if (a.Key.A.Type.Equals(typeof(bool))) return "boolean" + postfix;
                    if (a.Key.A.Type.Equals(typeof(DateTime))) return "timestamp without time zone" + postfix;
                    if (a.Key.A.Type.Equals(typeof(string))) return "text" + postfix;
                    throw new InvalidTypeException(a.Key.A.Type, nameof(PropertyKeyAttribute) + "." + nameof(PropertyKeyAttribute.Type) + " (" + a.Key.A.Type + ") defined for " + typeof(DBField) + "." + f.ToString() + " is not valid");
                })();
            })) + "\r\n" +
            "  CONSTRAINT " + _tableName + "_pk PRIMARY KEY (" + DBField.id + @") 
)
WITH(
  OIDS = FALSE
);

ALTER TABLE " + _tableName + @"
  OWNER TO " + _objectsOwner + @";

COMMENT ON TABLE " + _tableName + @" IS 'Main property table'; 
" +
            string.Join("\r\n", Util.EnumGetValues((DBField)(-1)).Select(f => f.A().Key).Select(f =>
                "COMMENT ON COLUMN " + _tableName + "." + f.A.EnumValue + " IS '" + makeSQLSafe(f.A.Description) + (string.IsNullOrEmpty(f.A.LongDescription) ? "" : (" // " + nameof(f.A.LongDescription) + ": " + f.A.LongDescription)) + "';")) +

        @"

CREATE SEQUENCE " + SEQUENCE_NAME + @"
INCREMENT 1
MINVALUE 1
MAXVALUE 9223372036854775807
START 1000  -- Starting with 1000 is a trick that makes it possible in API calls to have the range 1 to 999 signify entity specific id's (for instance like node-id's for an IoT gateway (like Z-Wave Node ID))
CACHE 1; -- TODO: Use COMMENT ON for comment above!

ALTER TABLE " + SEQUENCE_NAME + @"
OWNER TO " + _objectsOwner + @";

CREATE INDEX " + _tableName + @"_" + DBField.invalid + @"_is_null 
  ON public." + _tableName + @"
  USING btree
  (" + DBField.invalid + @") -- TODO: Use COMMENT ON for comment below
  WHERE " + DBField.invalid + @" IS NULL; -- Important index if you have lots of historical invalid data (in order to quickly query current data)

CREATE INDEX " + _tableName + "_" + DBField.pid + @"
  ON public." + _tableName + @"
  USING btree
  (" + DBField.pid + @");
"; // TOOD: Add some configuration value for username here 
        })());

        // 
        private string _propertySelect;
        public string PropertySelect => _propertySelect ?? (_propertySelect =
            "SELECT " +
            string.Join(", ", Util.EnumGetValues((DBField)(-1)).Select(e => e.ToString())) + " " +
            "FROM " + _tableName + " "); // Do not terminate with ";" here. Usually a WHERE-clause will be added

        protected bool IsDisposed = false;
        /// <summary>
        /// Standard AgoRapide principle is to explicit call dispose at the end of a each 
        /// Controller method with BaseController.DBDispose like:
        /// try {
        ///   ...
        /// } finally {
        ///    DBDispose();
        /// }
        /// It is important to close connections because we do not close after each query. 
        /// </summary>
        public override void Dispose() {
            if (IsDisposed) return;

            Log("");

            if (_cn1 != null) {
                try {
                    _cn1.Close();
                    _cn1 = null;
                    Log("_cn1 closed OK");
                } catch (Exception ex) {
                    Log("_cn1 " + ex.GetType().ToString() + ", " + ex.Message);
                }
            }
            try {
                Npgsql.NpgsqlConnection.ClearAllPools();
                Log("Npgsql.NpgsqlConnection.ClearAllPools OK");
            } catch (Exception ex) {
                Log("Npgsql.NpgsqlConnection.ClearAllPools " + ex.GetType().ToString() + ", " + ex.Message);
            }
            IsDisposed = true;
        }

        public class PostgreSQLDatabaseException : ApplicationException {
            public PostgreSQLDatabaseException(Npgsql.NpgsqlCommand command, Exception inner) : this(command, null, inner) { }
            public PostgreSQLDatabaseException(Npgsql.NpgsqlCommand command, string message, Exception inner) : base("Exception " + inner.GetType() + " occurred when executing " + typeof(Npgsql.NpgsqlCommand) + " '" + command.CommandText + "'" + (string.IsNullOrEmpty(message) ? "" : ("Details: " + message)), inner) { }
        }

        private Npgsql.NpgsqlConnection GetLock(Npgsql.NpgsqlCommand cmd) => cmd.Connection ?? throw new NullReferenceException(
            "No connection specified for query\r\n" +
            cmd.CommandText + ".\r\n" +
            ((_cn1 == null || string.IsNullOrEmpty(_connectionString)) ?
                ("Possible cause: " + nameof(_cn1) + " is null or " + nameof(_connectionString) + " not given") :
                ("Possible resolution: Add " + nameof(_cn1) + " as last parameter to initialization of " + cmd.GetType())
            ));
    }
}