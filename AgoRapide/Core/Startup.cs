using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using AgoRapide.Core;
using AgoRapide.Database;
using AgoRapide.API;

namespace AgoRapide.Core {

    [Class(Description = "Contains code called at application startup (normally from an application-specific Startup.cs-file located in the client root-folder)")]
    public class Startup {

        /// <summary>
        /// </summary>
        /// <typeparam name="TPerson">Type of <see cref="ConfigurationAttribute.AnonymousUser"/> and <see cref="ConfigurationAttribute.SystemUser"/></typeparam>
        /// <param name="controllers">See <see cref="APIMethod.CreateSemiAutogeneratedMethods"/></param>
        /// <param name="attributeClassesSignifyingRequiresAuthorization">See <see cref="APIMethod.CreateSemiAutogeneratedMethods"/></param>
        /// <param name="clientAssemblies">Assemblies into which to look for enums and classes</param>
        /// <param name="Log">First parameter is category, second parameter is actual log-text</param>
        public System.Web.Http.HttpConfiguration Initialize<TPerson>(
            List<Type> attributeClassesSignifyingRequiresAuthorization,
            List<System.Reflection.Assembly> clientAssemblies,
            Action<string, string> Log
        ) where TPerson : BaseEntity, new() {

            Log(nameof(PropertyKeyMapper.AllCoreP), nameof(PropertyKeyMapper.AllCoreP) + ":\r\n\r\n" + string.Join("\r\n", PropertyKeyMapper.AllCoreP.Select(c => c.Key.A.EnumValueExplained)) + "\r\n");

            string mapper<T>() => typeof(T) + " => " + AgoRapide.Core.Util.MapTToCoreP<T>().Key.A.EnumValueExplained + "\r\n";
            Log(null, "\r\n\r\n" +
                "Testing " + nameof(Util.MapTToCoreP) + " for a few enums\r\n\r\n" +
                mapper<ResultCode>() + /// Maps to <see cref="CoreP.ResultCode"/>
                mapper<APIMethodOrigin>()  /// Maps to <see cref="CoreP.APIMethodOrigin"/>
            );

            new TPerson().Use(p => {
                p.AddProperty(Extensions.A(CoreP.AccessLevelGiven), AccessLevel.System);
                Util.Configuration.C.SystemUser = p;
            });

            Log(null, "Attempting to connect to database. If connection fails check that the database has been created according to just earlier supposed logged SQL-code");
            var _db = Util.Configuration.C.DatabaseGetter(GetType());

            Log(nameof(ApplicationPart), "Reading all " + typeof(ClassMember)); // Important before we ask for startupAsApplicationPart
            ApplicationPart.GetFromDatabase<ClassMember>(_db, text => Log(nameof(ApplicationPart), "(by " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            var startupAsApplicationPart = ApplicationPart.GetClassMember(System.Reflection.MethodBase.GetCurrentMethod(), _db);
            _db.UpdateProperty(startupAsApplicationPart.Id, startupAsApplicationPart, key: CoreP.Log.A(), value: "Initiating startup", result: null);

            // ---------------------

            Log(nameof(ApplicationPart), "Reading all " + typeof(Class));
            ApplicationPart.GetFromDatabase<Class>(_db, text => Log(nameof(ApplicationPart), "(by " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            // ClassMember was read above

            Log(nameof(ApplicationPart), "Reading all " + typeof(Enum));
            ApplicationPart.GetFromDatabase<Enum>(_db, text => Log(nameof(ApplicationPart), "(by " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            Log(nameof(ApplicationPart), "Reading all " + typeof(EnumValue));
            ApplicationPart.GetFromDatabase<EnumValue>(_db, text => Log(nameof(ApplicationPart), "(by " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            Log(nameof(CoreP.IsAnonymous), "Looking for " + CoreP.IsAnonymous + " persons");
            Util.Configuration.C.AnonymousUser = new Func<BaseEntity>(() => {
                if (_db.TryGetEntity(Util.Configuration.C.SystemUser, new QueryIdKeyOperatorValue(CoreP.IsAnonymous.A().Key, Operator.EQ, true), AccessType.Read, entity: out TPerson retval, errorResponse: out var errorResponse)) {
                    Log(nameof(CoreP.IsAnonymous), "Found as " + retval.Id);
                    return retval;
                }
                Log(nameof(CoreP.IsAnonymous), CoreP.IsAnonymous + " person not found, creating one");
                retval = _db.GetEntityById<TPerson>(_db.CreateEntity<TPerson>(
                    cid: startupAsApplicationPart.Id,
                    properties: new Dictionary<CoreP, object> {
                            { CoreP.IdFriendly, "anonymous"},
                            { CoreP.IsAnonymous, true },
                            { CoreP.AccessLevelRead, AccessLevel.Anonymous },
                            { CoreP.AccessLevelWrite, AccessLevel.System }
                    }.Select(e => (e.Key.A().PropertyKeyWithIndex, e.Value)).ToList(),
                    result: null));
                Log(nameof(CoreP.IsAnonymous), "Created new as " + retval.Id);
                return retval;
            })();

            Log(nameof(Configuration), "Reading all (or rather the single) " + typeof(Configuration));
            ApplicationPart.GetFromDatabase<Configuration>(_db, text => Log(nameof(Configuration), "(by " + typeof(Configuration) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            Log(nameof(Configuration), "Writing configuration to database");
            Util.Configuration.ConnectWithDatabasePublicAccess(_db);

            /// --------------------- <see cref="APIMethod"/>

            Log(nameof(APIMethod), "Reading all " + typeof(APIMethod));
            ApplicationPart.GetFromDatabase<APIMethod>(_db, text => Log(nameof(APIMethod), "(by " + typeof(ApplicationPart) + "." + nameof(ApplicationPart.GetFromDatabase) + ") " + text)); // TODO: Fix better logging mechanism here

            Log(null, "Calling " + nameof(APIMethod.CreateSemiAutogeneratedMethods));
            APIMethod.CreateSemiAutogeneratedMethods(clientAssemblies.SelectMany(a => a.GetTypes()).Where(t => typeof(BaseController).IsAssignableFrom(t)).ToList(), attributeClassesSignifyingRequiresAuthorization, _db);

            Log(null, "Calling " + nameof(APIMethod.CreateAutogeneratedMethods));
            APIMethod.CreateAutogeneratedMethods(_db);

            Log(nameof(APIMethod), "The following methods where found by " +
                nameof(APIMethod) + "." + nameof(APIMethod.CreateSemiAutogeneratedMethods) + " and " +
                nameof(APIMethod) + "." + nameof(APIMethod.CreateAutogeneratedMethods) + ":\r\n\r\n" +
                string.Join("\r\n", APIMethod.AllMethods.Select(m => m.ToString())) + "\r\n");

            if (APIMethod.IgnoredMethods.Count > 0) {
                /// Note that we do not delete from the database in cases like this
                /// (in general as of Feb 2017 we do not have deletion of <see cref="AgoRapide.ApplicationPart"/> no longer in the C# code)
                Log(nameof(APIMethod),
                    "In addition the following methods are present in the C# code " +
                    "but where ignored because the " + nameof(Environment) + " " +
                    "does not match the current one (" + Util.Configuration.C.Environment + "):\r\n\r\n" +
                    string.Join("\r\n", APIMethod.IgnoredMethods.Select(m => m.ToString() + " (" + nameof(m.MA.Environment) + ": " + m.MA.Environment + ")")) + "\r\n");
            }

            /// --------------------- <see cref="Documentator"/>

            Log(null, "Calling " + nameof(Documentator) + "." + nameof(Documentator.IndexKnowEntities));
            Documentator.IndexKnowEntities(_db); // TODO: Make more logical choice of methdod names and placing of logic

            /// Note how <see cref="Documentator.IndexKnowEntities"/> is not able to index 
            /// entities residing outside its own assembly. We must therefore index "our own" entities by ourselves now.
            Log(nameof(Documentator), nameof(Enum.RegisterAndIndexEnum));
            clientAssemblies.SelectMany(a => a.GetTypes()).Where(t => t.IsEnum).ToList().ForEach(t => {
                Log(nameof(Documentator), "Calling " + nameof(Enum) + "." + nameof(Enum.RegisterAndIndexEnum) + " for " + t.ToString());
                Enum.RegisterAndIndexEnum(t, _db);
            });

            Log(nameof(Documentator), nameof(Class.RegisterAndIndexClass));
            clientAssemblies.SelectMany(a => a.GetTypes()).Where(t => !t.IsEnum).ToList().ForEach(t => {
                Log(nameof(Documentator), "Calling " + nameof(Class) + "." + nameof(Class.RegisterAndIndexClass) + " for " + t.ToString());
                Class.RegisterAndIndexClass(t, _db);
            });

            Log(nameof(Documentator), "Calling " + nameof(Documentator) + "." + nameof(Documentator.IndexFinalize));
            var replacements = Documentator.IndexFinalize();
            Log(nameof(Documentator), "The following documentation keys where found:\r\n\r\n" +
                string.Join("\r\n\r\n", replacements.OrderBy(e => e.Key).Select(e => e.Key + "\r\n" + e.Value)) +
                "\r\n\r\n");

            Log(nameof(APIMethod), "Calling " + nameof(APIMethod) + "." + nameof(APIMethod.SetImplementatorIdAndCompleteAllEntityTypes));
            APIMethod.SetImplementatorIdAndCompleteAllEntityTypes(_db);

            Log(nameof(APIMethod), "Calling " + nameof(Util) + "." + nameof(Util.GetTypeFromString) + " (as assertion that works)");
            Util.GetTypeFromString(typeof(APIMethod).ToStringVeryShort());

            { /// Create all combinations of <see cref="AggregationKey"/> for <see cref="CountP"/>
                Log("MapEnums", "Creating " + nameof(CountP) + " aggregations");
                var aggregations = new StringBuilder();
                Util.EnumGetValues<CountP>().ForEach(c => {
                    var attribute = c.A();
                    APIMethod.AllEntityTypes.ForEach(t => {
                        attribute.Key.A.AggregationTypes.ForEach(a => {
                            aggregations.AppendLine(AggregationKey.GetAggregationKey(a, t, attribute).Key.PToString);
                        });
                    });
                });
                Log("MapEnums", nameof(CountP) + " aggregations:\r\n\r\n" + aggregations + "\r\n");
            }

            Log("EntityRelations", "\r\n\r\nEntity relation traversals found:" + string.Join("", APIMethod.AllEntityTypes.OrderBy(t => t.ToStringVeryShort()).Select(t => "\r\nFrom: " + t + ": " +
                string.Join("", Context.GetPossibleTraversalsFromType(t).Select(e => (e.Value == null ? "" : ("\r\nTo: " + e.Key + " via " + string.Join(", ", e.Value))))))) + "\r\n\r\n");

            Log("EntityRelations", "Asserting traversal from " + typeof(APIMethod) + " to " + typeof(ClassMember) + " in order to expose any issues at once");
            Context.GetTraversal(typeof(APIMethod), typeof(ClassMember));

            /// ----------------------------
            var httpConfiguration = new System.Web.Http.HttpConfiguration();
            Log(nameof(APIMethod), "Calling " + nameof(APIMethodMapper) + "." + nameof(APIMethodMapper.MapHTTPRoutes));
            APIMethodMapper.MapHTTPRoutes(httpConfiguration, APIMethod.AllMethods.Where(m => m.Origin != APIMethodOrigin.Autogenerated).ToList());

            Log(null, "Removing XmlFormatter");
            httpConfiguration.Formatters.Remove(httpConfiguration.Formatters.XmlFormatter);
            Log(null, "Adding JSONFormatter");
            httpConfiguration.Formatters.JsonFormatter.MediaTypeMappings.Add(new System.Net.Http.Formatting.QueryStringMapping("json", "true", "application/json"));
            Log(null, "Completed");
            _db.UpdateProperty(startupAsApplicationPart.Id, startupAsApplicationPart, key: CoreP.Log.A(), value: "Completed startup", result: null);

            return httpConfiguration;
        }
    }
}